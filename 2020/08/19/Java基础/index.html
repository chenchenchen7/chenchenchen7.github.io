<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java基础 | ChenChenChen's Blog</title><meta name="description" content="变量创建一个Hero对象会用到new关键字，但是给一个基本类型变量赋值却不是用new. 因为基本类型是Java语言里的一种内置的特殊数据类型，并不是某个类的对象。给基本类型的变量赋值的方式叫做 字面值，如下所例： 八种变量 整型 （4种）byte、short、int、long     字符型 （1种） 16位，只能存放一个字符 char c &#x3D; &#39;中&#39;  浮点型 （2种） 注意："><meta name="author" content="Chen Jiahui"><meta name="copyright" content="Chen Jiahui"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/08/19/Java%E5%9F%BA%E7%A1%80/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Java基础"><meta property="og:url" content="http://yoursite.com/2020/08/19/Java%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="ChenChenChen's Blog"><meta property="og:description" content="变量创建一个Hero对象会用到new关键字，但是给一个基本类型变量赋值却不是用new. 因为基本类型是Java语言里的一种内置的特殊数据类型，并不是某个类的对象。给基本类型的变量赋值的方式叫做 字面值，如下所例： 八种变量 整型 （4种）byte、short、int、long     字符型 （1种） 16位，只能存放一个字符 char c &#x3D; &#39;中&#39;  浮点型 （2种） 注意："><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-08-19T15:04:05.000Z"><meta property="article:modified_time" content="2020-08-19T15:04:27.032Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.0.0',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-08-19 23:04:27'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.0.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">14</div></a></div></div></div><hr/></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E7%A7%8D%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">八种变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">命名规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E4%BF%AE%E9%A5%B0"><span class="toc-number">1.5.</span> <span class="toc-text">final修饰</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">Arrays工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#copyOfRange"><span class="toc-number">2.1.1.</span> <span class="toc-text">copyOfRange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-NaN"><span class="toc-number">2.1.2.</span> <span class="toc-text">toString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-number">2.1.3.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#equals"><span class="toc-number">2.1.4.</span> <span class="toc-text">equals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fill"><span class="toc-number">2.1.5.</span> <span class="toc-text">fill</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">3.1.</span> <span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this"><span class="toc-number">3.3.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">类属性与类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">3.5.1.</span> <span class="toc-text">类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">类方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.6.</span> <span class="toc-text">属性初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">3.7.1.</span> <span class="toc-text">饿汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">3.7.2.</span> <span class="toc-text">懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number">3.7.3.</span> <span class="toc-text">面试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.8.</span> <span class="toc-text">枚举类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">4.</span> <span class="toc-text">接口与继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-number">4.1.</span> <span class="toc-text">重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">4.2.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E8%97%8F"><span class="toc-number">4.3.</span> <span class="toc-text">隐藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.4.</span> <span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#toString"><span class="toc-number">4.5.1.</span> <span class="toc-text">toString()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">4.5.2.</span> <span class="toc-text">finalize()垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode"><span class="toc-number">4.5.3.</span> <span class="toc-text">hashCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">4.5.4.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getClass"><span class="toc-number">4.5.5.</span> <span class="toc-text">getClass()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">4.6.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.7.</span> <span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.8.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.8.1.</span> <span class="toc-text">非静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">4.8.2.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">4.8.3.</span> <span class="toc-text">匿名类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E7%B1%BB"><span class="toc-number">4.8.4.</span> <span class="toc-text">本地类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">4.9.</span> <span class="toc-text">默认方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">数字与字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">封装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">Number类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1-%E6%8B%86%E7%AE%B1"><span class="toc-number">5.3.</span> <span class="toc-text">自动装箱&#x2F;拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">5.4.</span> <span class="toc-text">int的最大值，最小值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer"><span class="toc-number">5.5.</span> <span class="toc-text">StringBuffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F"><span class="toc-number">5.6.</span> <span class="toc-text">日期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.6.1.</span> <span class="toc-text">日期转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%97%A5%E6%9C%9F"><span class="toc-number">5.6.2.</span> <span class="toc-text">字符串转日期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">6.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-catch"><span class="toc-number">6.1.1.</span> <span class="toc-text">try catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E7%88%B6%E7%B1%BBcatch"><span class="toc-number">6.1.2.</span> <span class="toc-text">异常的父类catch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%BC%82%E5%B8%B8%E6%8D%95%E6%8D%89%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.3.</span> <span class="toc-text">多异常捕捉方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally"><span class="toc-number">6.1.4.</span> <span class="toc-text">finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throws"><span class="toc-number">6.1.5.</span> <span class="toc-text">throws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.1.6.</span> <span class="toc-text">throw和throws的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">异常分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="toc-number">6.2.1.</span> <span class="toc-text">可查异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-number">6.2.2.</span> <span class="toc-text">运行时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF"><span class="toc-number">6.2.3.</span> <span class="toc-text">错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">6.2.4.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E9%9D%9E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">运行时异常与非运行时异常的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Throwable"><span class="toc-number">6.3.1.</span> <span class="toc-text">Throwable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">6.4.</span> <span class="toc-text">创建自定义异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#I-O"><span class="toc-number">7.</span> <span class="toc-text">I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81"><span class="toc-number">7.1.</span> <span class="toc-text">流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%87%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.</span> <span class="toc-text">中文问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%B5%81"><span class="toc-number">7.3.</span> <span class="toc-text">缓存流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferedReader"><span class="toc-number">7.3.1.</span> <span class="toc-text">BufferedReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrintWriter"><span class="toc-number">7.3.2.</span> <span class="toc-text">PrintWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flush"><span class="toc-number">7.3.3.</span> <span class="toc-text">flush</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">7.4.</span> <span class="toc-text">数据流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">7.5.</span> <span class="toc-text">对象流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">8.</span> <span class="toc-text">集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList"><span class="toc-number">8.1.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.1.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.1.2.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.3.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList"><span class="toc-number">8.2.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">8.2.1.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">8.3.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet"><span class="toc-number">8.4.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E5%92%8CHashMap%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.5.</span> <span class="toc-text">HashSet和HashMap的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection"><span class="toc-number">8.6.</span> <span class="toc-text">Collection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections"><span class="toc-number">8.7.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList-vs-HashSet"><span class="toc-number">8.8.</span> <span class="toc-text">ArrayList vs HashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-vs-HashTable"><span class="toc-number">8.9.</span> <span class="toc-text">HashMap vs HashTable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E7%A7%8DSet"><span class="toc-number">8.10.</span> <span class="toc-text">几种Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashcode%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.11.</span> <span class="toc-text">hashcode的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">8.12.</span> <span class="toc-text">比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparator"><span class="toc-number">8.12.1.</span> <span class="toc-text">Comparator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparable"><span class="toc-number">8.12.2.</span> <span class="toc-text">Comparable</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B-1"><span class="toc-number">9.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">支持泛型的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">9.2.</span> <span class="toc-text">通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extends"><span class="toc-number">9.2.1.</span> <span class="toc-text">? extends</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">9.2.2.</span> <span class="toc-text">? super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">9.2.3.</span> <span class="toc-text">泛型通配符?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.2.4.</span> <span class="toc-text">泛型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">10.1.</span> <span class="toc-text">聚合操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">11.1.</span> <span class="toc-text">创建多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%BA%BF%E7%A8%8B%E7%B1%BB"><span class="toc-number">11.1.1.</span> <span class="toc-text">继承线程类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.1.2.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB-1"><span class="toc-number">11.1.3.</span> <span class="toc-text">匿名类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">常见线程方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep"><span class="toc-number">11.2.1.</span> <span class="toc-text">sleep()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">11.2.2.</span> <span class="toc-text">join()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setPriority"><span class="toc-number">11.2.3.</span> <span class="toc-text">setPriority()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield"><span class="toc-number">11.2.4.</span> <span class="toc-text">yield()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setDaemon"><span class="toc-number">11.2.5.</span> <span class="toc-text">setDaemon()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">11.3.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">11.4.</span> <span class="toc-text">线程安全的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-vs-HashTable-1"><span class="toc-number">11.4.1.</span> <span class="toc-text">HashMap vs HashTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer-vs-StringBuilder"><span class="toc-number">11.4.2.</span> <span class="toc-text">StringBuffer vs StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-vs-Vector"><span class="toc-number">11.4.3.</span> <span class="toc-text">ArrayList vs Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">11.4.4.</span> <span class="toc-text">把非线程安全的集合转换为线程安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">11.5.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92"><span class="toc-number">11.6.</span> <span class="toc-text">交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">11.7.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock%E5%AF%B9%E8%B1%A1"><span class="toc-number">11.8.</span> <span class="toc-text">Lock对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E8%AE%BF%E9%97%AE"><span class="toc-number">11.9.</span> <span class="toc-text">原子访问</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">12.</span> <span class="toc-text">工具和中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">12.1.</span> <span class="toc-text">调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%BA%94%E7%94%A8Debug"><span class="toc-number">12.1.1.</span> <span class="toc-text">Java应用Debug</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">ChenChenChen's Blog</a></span><span class="pull-right menus"><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java基础</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-19T15:04:05.000Z" title="发表于 2020-08-19 23:04:05">2020-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-08-19T15:04:27.032Z" title="更新于 2020-08-19 23:04:27">2020-08-19</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>创建一个Hero对象会用到new关键字，但是给一个基本类型变量赋值却不是用new. 因为基本类型是Java语言里的一种内置的特殊数据类型，并不是某个类的对象。<br>给基本类型的变量赋值的方式叫做 <strong>字面值</strong>，如下所例：</p>
<h2 id="八种变量"><a href="#八种变量" class="headerlink" title="八种变量"></a>八种变量</h2><ul>
<li><p>整型 （4种）byte、short、int、long</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200807214534181.png" alt="image-20200807214534181"></p>
</li>
</ul>
<ul>
<li><p>字符型 （1种）</p>
<p><strong>16位，只能存放一个字符</strong> <code>char c = &#39;中&#39;</code></p>
</li>
<li><p>浮点型 （2种）</p>
<p><strong>注意： 默认的小数值是double类型的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">double</span> d = <span class="number">123.45</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//该行会出现编译错误，因为54.321是double型的</span></span><br><span class="line">      <span class="comment">//给一个小数，首先默认的就是double类型，想要float类型需要加f</span></span><br><span class="line">      <span class="keyword">float</span> f = <span class="number">54.321</span>;</span><br><span class="line">      <span class="keyword">float</span> f2 = <span class="number">54.321f</span>;</span><br><span class="line">        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<p>  <img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200807215157797.png" alt="image-20200807215157797"></p>
<ul>
<li><p>布尔型（1种）</p>
</li>
<li><p>String类型</p>
<blockquote>
<p>String类型其实<strong>并不是基本类型</strong>，但是它是如此广泛的被使用，常常被误以为是一种基本类型。<br>String类型是Immutable的，一旦创建就不能够被改变，更多的关于String的学习，<a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-string/324.html#step700">请参考String</a></p>
</blockquote>
</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>转换规则：</strong></p>
<ul>
<li><p>低精度可以向高精度转换</p>
</li>
<li><p>高精度不一定可以向低精度转换</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200807221831698.png" alt="image-20200807221831698"></p>
</li>
</ul>
<p><strong>高向低转换的经典情况</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200807222408276.png" alt="image-20200807222408276"></p>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol>
<li><p>变量命名只能使用<strong>字母 数字 $ _</strong><br>变量第一个字符 只能使用 字母 $ _<br>变量第一个字符 不能使用数字</p>
</li>
<li><p>在命名的时候，尽量使用完整的单词进行命名，比如name,moveSpeed，而不是使用缩写 n,m。</p>
</li>
<li><p>命名时尽量不要使用关键字</p>
<blockquote>
<p>关键字列表</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808095011738.png" alt="image-20200808095011738"><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808095017930.png" alt="image-20200808095017930"></p>
</li>
<li><p>中文也可以用来命名，<strong>但是实际工作中不要这样干</strong></p>
</li>
</ol>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ol>
<li><p>当一个变量被声明在类下面<br>变量就叫做<strong>字段</strong> 或者<strong>属性</strong>、<strong>成员变量</strong>、<strong>Field</strong></p>
<p><strong>整个类都可以访问得到</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">//字段/属性/成员变量/Field</span></span><br><span class="line">    <span class="keyword">int</span> j = i;  <span class="comment">//其他的属性可以访问i</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(i); <span class="comment">//方法1里可以访问i</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(i); <span class="comment">//方法2里可以访问i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个变量，是声明在一个方法上的，就叫做<strong>参数</strong><br>参数的作用域即为该方法内的所有代码<br>其他方法不能访问该参数<br>类里面也不能访问该参数</p>
</li>
<li><p>声明在方法内的变量，叫做<strong>局部变量</strong></p>
<p>其作用域在声明开始的位置，到其所处于的块结束位置</p>
</li>
</ol>
<h2 id="final修饰"><a href="#final修饰" class="headerlink" title="final修饰"></a>final修饰</h2><p>final 修饰一个变量，有很多种说法，比如不能改变等等<br>准确的描述是 当一个变量被final修饰的时候，该变量<strong>只有一次赋值的机会</strong></p>
<p>final除了可以修饰变量，还可以修饰类，修饰方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">         </span><br><span class="line">        i = <span class="number">10</span>; <span class="comment">//i在第4行已经被赋值过了，所以这里会出现编译错误</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">         </span><br><span class="line">        i = <span class="number">10</span>; <span class="comment">//i在第4行，只是被声明，但是没有被赋值，所以在这里可以进行第一次赋值</span></span><br><span class="line">         </span><br><span class="line">        i = <span class="number">11</span>; <span class="comment">//i在第6行已经被赋值过了，所以这里会出现编译错误</span></span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays</span><br></pre></td></tr></table></figure>



<p>Arrays是针对数组的<strong>工具类</strong>，可以进行 排序，查找，复制填充等功能。 大大提高了开发人员的工作效率。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808132243473.png" alt="image-20200808132243473"></p>
<h3 id="copyOfRange"><a href="#copyOfRange" class="headerlink" title="copyOfRange"></a>copyOfRange</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// copyOfRange(int[] original, int from, int to)</span></span><br><span class="line">        <span class="comment">// 第一个参数表示源数组</span></span><br><span class="line">        <span class="comment">// 第二个参数表示开始位置(取得到)</span></span><br><span class="line">        <span class="comment">// 第三个参数表示结束位置(取不到)</span></span><br><span class="line">        <span class="keyword">int</span>[] b = Arrays.copyOfRange(a, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            System.out.print(b[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>如果要打印一个数组的内容，就需要通过for循环来挨个遍历，逐一打印</p>
<p>但是Arrays提供了一个toString()方法，直接把一个数组，转换为字符串，这样方便观察数组的内容</p>
<p>代码比较复制代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        String content = Arrays.toString(a);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><blockquote>
<p>有机会可以看一看sort的源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序之前 :&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序之后:&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>比较两个数组的<strong>内容</strong>是否一样<br>第二个数组的最后一个元素<strong>是8</strong>，和第一个数组不一样，所以比较结果是false</p>
<p>==用来比较用于判断两个对象是否相同。<strong>更准确的讲</strong>，用于判断两个引用，是否指向了同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">9</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> b[] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">18</span>, <span class="number">62</span>, <span class="number">68</span>, <span class="number">82</span>, <span class="number">65</span>, <span class="number">8</span> &#125;;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Arrays.equals(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p>使用同一个值，填充整个数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">  </span><br><span class="line">        Arrays.fill(a, <span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p><strong>方法的重载指的是方法名一样，但是参数类型不一样</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据传递参数的不同，会调用不同的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1, Hero h2)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 如果要攻击更多的Hero，要怎么写？</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero h1,Hero h2,Hero h3)</span> <span class="comment">//太费事</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">(Hero ...heros)</span></span></span><br><span class="line"><span class="function">hero.<span class="title">attack</span><span class="params">(h1, h2, h3, h4)</span> <span class="comment">//根据你写的h1,h2,h3...等来调用</span></span></span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>方法名和类名一样（包括大小写）<br><strong>没有返回类型</strong><br>实例化一个对象的时候，必然调用构造方法 </p>
<p>构造方法也可以重载，即构造不同的参数  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法名和类名一样（包括大小写）</span></span><br><span class="line">    <span class="comment">// 没有返回类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例化一个对象的时候，必然调用构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实例化一个对象的时候，必然调用构造方法</span></span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有写构造方法，则会默认提供一个隐式的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span></span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果提供了有参的构造函数，同时又<strong>没有显式</strong>的提供一个无参的构造方法<br>那么默认的无参的构造方法，就“木有了“</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">    <span class="comment">//有参的构造方法</span></span><br><span class="line">    <span class="comment">//默认的无参的构造方法就失效了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String heroname)</span></span>&#123; </span><br><span class="line">        name = heroname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero garen =  <span class="keyword">new</span> Hero(<span class="string">&quot;盖伦&quot;</span>);    </span><br><span class="line">        Hero teemo =  <span class="keyword">new</span> Hero(); <span class="comment">//无参的构造方法“木有了”</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ol>
<li><p>this代表当前对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="comment">//打印内存中的虚拟地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAddressInMemory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印this看到的虚拟地址：&quot;</span>+<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero garen =  <span class="keyword">new</span> Hero();</span><br><span class="line">        <span class="comment">//直接打印对象，会显示该对象在内存中的虚拟地址</span></span><br><span class="line">        <span class="comment">//格式：Hero@c17164 c17164即虚拟地址，每次执行，得到的地址不一定一样</span></span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;打印对象看到的虚拟地址：&quot;</span>+garen);</span><br><span class="line">        <span class="comment">//调用showAddressInMemory，打印该对象的this，显示相同的虚拟地址</span></span><br><span class="line">        garen.showAddressInMemory();</span><br><span class="line">    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li>通过this访问属性</li>
</ol>
<ol start="3">
<li><p>通过this调用其他的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;一个参数的构造方法&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//带两个参数的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name,<span class="keyword">float</span> hp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name);<span class="comment">//指上面那个构造方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;两个参数的构造方法&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.hp = hp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><ol>
<li>属性通常使用private封装起来</li>
<li>方法一般使用public用于被调用</li>
<li>会被子类继承的方法，通常使用protected</li>
<li>package用的不多，一般新手会用package,因为还不知道有修饰符这个东西</li>
</ol>
<p>再就是<strong>作用范围最小原则</strong><br>简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。 这样就能把数据尽量的封装起来，没有必要<strong>露出来的</strong>，就不用<strong>露出来</strong>了</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808155603770.png" alt="image-20200808155603770"></p>
<h2 id="类属性与类方法"><a href="#类属性与类方法" class="headerlink" title="类属性与类方法"></a>类属性与类方法</h2><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><p><strong>类属性：</strong> 又叫做静态属性<br><strong>对象属性：</strong> 又叫实例属性，非静态属性<br>如果一个属性声明成类属性，那么所有的对象，都共享这么一个值<br>给英雄设置一个类属性叫做“版权” (copyright), 无论有多少个具体的英雄，所有的英雄的版权都属于 Riot Games公司。</p>
<p><strong>访问类属性</strong></p>
<p>对象.类属性    <code>teemo.copyright</code><br>类.类属性    <code>Hero.copyright</code>  <strong>既然是类属性，就推荐这种方式访问</strong></p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p><strong>类方法：</strong> 又叫做静态方法</p>
<p><strong>对象方法：</strong> 又叫实例方法，非静态方法</p>
<p>访问一个对象方法，必须<strong>建立在有一个对象</strong>的前提的基础上<br>访问类方法，<strong>不需要对象</strong>的存在，直接就访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">float</span> hp;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//实例方法,对象方法，非静态方法</span></span><br><span class="line">    <span class="comment">//必须有对象才能够调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span></span>&#123;</span><br><span class="line">        hp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//类方法，静态方法</span></span><br><span class="line">    <span class="comment">//通过类就可以直接调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">battleWin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           Hero garen =  <span class="keyword">new</span> Hero();</span><br><span class="line">           garen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">           <span class="comment">//必须有一个对象才能调用</span></span><br><span class="line">           garen.die();</span><br><span class="line">            </span><br><span class="line">           Hero teemo =  <span class="keyword">new</span> Hero();</span><br><span class="line">           teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">            </span><br><span class="line">           <span class="comment">//无需对象，直接通过类调用</span></span><br><span class="line">           Hero.battleWin();       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如<code>Math.random</code></p>
<p>random()就是一个类方法，直接通过类Math进行调用，并没有一个Math的实例存在</p>
<h2 id="属性初始化"><a href="#属性初始化" class="headerlink" title="属性初始化"></a>属性初始化</h2><p>声明优先于块，块优先于构造方法，所以输出的是优先级最低的构造方法中的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classAndObject.chushihua;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroTest</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> String name = <span class="string">&quot;some hero&quot;</span>; </span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;声明&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HeroTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">            name = <span class="string">&quot;one hero&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="string">&quot;the hero&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroTest ht = <span class="keyword">new</span> HeroTest();</span><br><span class="line">        System.out.println(ht.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">声明</span><br><span class="line">块</span><br><span class="line">构造方法</span><br><span class="line">one hero</span><br></pre></td></tr></table></figure>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>LOL里有一个怪叫大龙GiantDragon，只有一只，所以该类，只能被实例化一次。</p>
<p>单例模式又叫做 Singleton模式，指的是一个类，在一个JVM里，只有一个实例存在。</p>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>GiantDragon 应该只有一只，通过私有化其构造方法，使得外部无法通过new 得到新的实例。<br>GiantDragon 提供了一个public static的getInstance方法，外部调用者通过该方法获取12行定义的对象，而且每一次都是获取同一个对象。 从而达到单例的目的。<br>这种单例模式又叫做<strong>饿汉式</strong>单例模式，无论如何都会创建一个实例</p>
<blockquote>
<p>先创建好，调用时候直接返回实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiantDragon</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GiantDragon</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//准备一个类属性，指向一个实例化对象。 因为是类属性，所以只有一个</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//public static 方法，提供给调用者获取12行定义的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p><strong>懒汉式</strong>单例模式与<strong>饿汉式</strong>单例模式不同，只有在调用getInstance的时候，才会创建实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiantDragon</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//私有化构造方法使得该类无法在外部通过new 进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GiantDragon</span><span class="params">()</span></span>&#123;       </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//准备一个类属性，用于指向一个实例化对象，但是暂时指向null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> GiantDragon instance;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//public static 方法，返回实例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GiantDragon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> GiantDragon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回 instance指向的对象</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>饿汉式</strong>是立即加载的方式，无论是否会用到这个对象，都会加载。<br>如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。</p>
<p><strong>懒汉式</strong>，是延迟加载的方式，只有使用的时候才会加载。 并且有<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-synchronized/355.html#step793">线程安全</a>的考量(鉴于同学们学习的进度，暂时不对线程的章节做展开)。<br>使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。</p>
<p>看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式</p>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>这个是面试的时候经常会考的点，面试题通常的问法是:</p>
<ul>
<li>什么是单例式？</li>
</ul>
<p>回答的时候，要答到三元素</p>
<ol>
<li>构造方法私有化</li>
<li>静态属性指向实例</li>
<li>public static的 getInstance方法，返回第二步的静态属性</li>
</ol>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举enum是一种特殊的类(还是类)，使用枚举可以很方便的定义常量<br>比如设计一个枚举类型 季节，里面有4种常量</p>
<ul>
<li><p>优点</p>
<p>假设在使用<a target="_blank" rel="noopener" href="https://how2j.cn/k/control-flow/control-flow-switch/272.html">switch</a>的时候，不是使用枚举，而是使用int，而int的取值范围就不只是1-4，有可能取一个超出1-4之间的值，这样判断结果就似是而非了。（因为只有4个季节）</p>
<p>但是使用枚举，就能把范围死死的限定在这四个当中(SPRING,SUMMER,AUTUMN,WINTER)</p>
</li>
<li><p>遍历枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Season s : Season.values()) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h1 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h1><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>子类可以继承父类的对象方法</p>
<p>在继承后，重复提供该方法，就叫做方法的重写</p>
<p>又叫覆盖 <strong>override</strong></p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li><p>操作符的多态<br>可以作为算数运算，也可以作为字符串连接</p>
</li>
<li><p>类的多态<br>父类引用指向子类对象</p>
</li>
</ul>
<p><strong>类多态的条件：</strong></p>
<ol>
<li>父类（接口）引用指向子类对象</li>
<li>调用的方法有重写</li>
</ol>
<h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>与重写类似，方法的<strong>重写是</strong>子类覆盖父类的<strong>对象方法</strong></p>
<p><strong>隐藏</strong>，就是子类覆盖父类的<strong>类方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">float</span> hp;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//类方法，静态方法</span></span><br><span class="line">    <span class="comment">//通过类就可以直接调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">battleWin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hero battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">AD</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//隐藏父类的battleWin方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">battleWin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ad hero battle win&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero.battleWin();</span><br><span class="line">        ADHero.battleWin();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>实例化一个子类时， 其构造方法会被调用<br>其<strong>父类的构造方法也会被调用</strong><br>并且是父类构造方法<strong>先调用</strong><br>子类构造方法会默认调用父类的 <strong>无参的构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类显式调用父类带参构造方法</span></span><br><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADHero</span> <span class="keyword">extends</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">AD</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">physicAttack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进行物理攻击&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ADHero</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);<span class="comment">//显式调用带参构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;AD Hero的构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ADHero(<span class="string">&quot;德莱文&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object类是所有类的父类</p>
<p>声明一个类的时候，默认是继承了Object<br>public class Hero <strong>extends Object</strong></p>
<h3 id="toString"><a href="#toString" class="headerlink" title="toString()"></a>toString()</h3><p>Object类提供一个toString方法，所以所有的类都有toString方法<br>toString()的意思是返回当前对象的<strong>字符串表达</strong><br>通过 System.out.println 打印对象就是打印该对象的toString()返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">float</span> hp;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">        h.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        System.out.println(h.toString());</span><br><span class="line">        <span class="comment">//直接打印对象就是打印该对象的toString()返回值</span></span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="finalize-垃圾回收"><a href="#finalize-垃圾回收" class="headerlink" title="finalize()垃圾回收"></a>finalize()垃圾回收</h3><p>当一个对象没有任何引用指向的时候，它就满足垃圾回收的条件</p>
<p>当它被垃圾回收的时候，它的finalize() 方法就会被调用。</p>
<p>finalize() 不是开发人员主动调用的方法，而是由虚拟机JVM调用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">float</span> hp;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这个英雄正在被回收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只有一引用</span></span><br><span class="line">        Hero h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//不断生成新的对象</span></span><br><span class="line">            <span class="comment">//每创建一个对象，前一个对象，就没有引用指向了</span></span><br><span class="line">            <span class="comment">//那些对象，就满足垃圾回收的条件</span></span><br><span class="line">            <span class="comment">//当，垃圾堆积的比较多的时候，就会触发垃圾回收</span></span><br><span class="line">            <span class="comment">//一旦这个对象被回收，它的finalize()方法就会被调用</span></span><br><span class="line">            h = <span class="keyword">new</span> Hero();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200809134830934.png" alt="image-20200809134830934"></p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>hashCode方法返回一个对象的哈希值</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>Object还提供线程同步相关方法<br>wait()<br>notify()<br>notifyAll()</p>
<h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>getClass()会返回一个对象的<a target="_blank" rel="noopener" href="https://how2j.cn/k/reflection/reflection-class/108.html">类对象</a>，属于高级内容，不适合初学者过早接触，关于类对象的详细内容请参考<a target="_blank" rel="noopener" href="https://how2j.cn/k/reflection/reflection-reflection/107.html">反射机制</a></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在类中声明一个方法，这个方法没有实现体，是一个“空”方法</p>
<p>这样的方法就叫抽象方法，使用修饰符“abstract”</p>
<p>当一个类有抽象方法的时候，该类必须被声明为抽象类</p>
<p><strong>抽象类不可以被实例化</strong></p>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><p>区别1：<br>子类只能继承一个抽象类，不能继承多个<br>子类可以实现<strong>多个</strong>接口<br>区别2：<br>抽象类可以定义：</p>
<ul>
<li>public,protected,package,private</li>
<li>静态和非静态属性</li>
<li>final和非final属性</li>
</ul>
<p>但是接口中声明的属性，只能是：</p>
<ul>
<li>public</li>
<li>静态</li>
<li>final的</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><p>非静态内部类 BattleScore “战斗成绩”<br>非静态内部类可以直接在一个类里面定义</p>
<p>比如：<br>战斗成绩只有在一个英雄对象存在的时候才有意义<br>所以实例化BattleScore 的时候，必须建立在一个存在的英雄的基础上<br>语法: <strong>new 外部类().new 内部类()</strong><br>作为Hero的非静态内部类，是可以直接访问外部类的<strong>private</strong>实例属性name的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">// 血量</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> armor; <span class="comment">// 护甲</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> moveSpeed; <span class="comment">// 移动速度</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 非静态内部类，只有一个外部类对象存在的时候，才有意义</span></span><br><span class="line">    <span class="comment">// 战斗成绩只有在一个英雄对象存在的时候才有意义</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BattleScore</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> kill;</span><br><span class="line">        <span class="keyword">int</span> die;</span><br><span class="line">        <span class="keyword">int</span> assit;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">legendary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (kill &gt;= <span class="number">8</span>)</span><br><span class="line">                System.out.println(name + <span class="string">&quot;超神！&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot;尚未超神！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hero garen = <span class="keyword">new</span> Hero();</span><br><span class="line">        garen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        <span class="comment">// 实例化内部类</span></span><br><span class="line">        <span class="comment">// BattleScore对象只有在一个英雄对象存在的时候才有意义</span></span><br><span class="line">        <span class="comment">// 所以其实例化必须建立在一个外部类对象的基础之上</span></span><br><span class="line">        BattleScore score = garen.<span class="function">new <span class="title">BattleScore</span><span class="params">()</span></span>;</span><br><span class="line">        score.kill = <span class="number">9</span>;</span><br><span class="line">        score.legendary();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>在一个类里面声明一个静态内部类<br>比如敌方水晶，当敌方水晶没有血的时候，己方所有英雄都取得胜利，而不只是某一个具体的英雄取得胜利。<br>与非静态内部类不同，<strong>静态内部类</strong>水晶类的实例化 <strong>不需要一个外部类的实例为基础</strong>，可以直接实例化<br>语法：<strong>new 外部类.静态内部类();</strong><br>因为没有一个外部类的实例，所以在静态内部类里面<strong>不可以访问外部类的实例属性和方法</strong><br>除了可以访问外部类的<strong>私有静态成员外</strong>，静态内部类和普通类没什么大的区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">float</span> hp;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">battleWin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;battle win&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//敌方的水晶</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnemyCrystal</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hp=<span class="number">5000</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//如果水晶的血量为0，则宣布胜利</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkIfVictory</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hp==<span class="number">0</span>)&#123;</span><br><span class="line">                Hero.battleWin();</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">//静态内部类不能直接访问外部类的对象属性</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot; win this game&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实例化静态内部类</span></span><br><span class="line">        Hero.EnemyCrystal crystal = <span class="keyword">new</span> Hero.EnemyCrystal();</span><br><span class="line">        crystal.checkIfVictory();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h3><p>匿名类指的是在<strong>声明一个类的同时实例化它</strong>，使代码更加简洁精练<br>通常情况下，要使用一个接口或者抽象类，都必须创建一个子类</p>
<p>有的时候，为了快速使用，直接实例化一个抽象类，并“<strong>当场</strong>”实现其抽象方法。<br>既然实现了抽象方法，那么就是一个新的类，只是这个类，没有命名。<br>这样的类，叫做匿名类</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200809144102059.png" alt="image-20200809144102059"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        ADHero adh=<span class="keyword">new</span> ADHero();</span><br><span class="line">        <span class="comment">//通过打印adh，可以看到adh这个对象属于ADHero类</span></span><br><span class="line">        adh.attack();</span><br><span class="line">        System.out.println(adh);</span><br><span class="line">          </span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero()&#123;</span><br><span class="line">            <span class="comment">//当场实现attack方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;新的进攻手段&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        h.attack();</span><br><span class="line">        <span class="comment">//通过打印h，可以看到h这个对象属于Hero$1这么一个系统自动分配的类名</span></span><br><span class="line">          </span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="本地类"><a href="#本地类" class="headerlink" title="本地类"></a>本地类</h3><p>本地类可以理解为有名字的匿名类<br>内部类与匿名类不一样的是，内部类必须声明在成员的位置，即与属性和方法平等的位置。<br>本地类和匿名类一样，直接声明在代码块里面，可以是主方法，for循环里等等地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    String name; <span class="comment">//姓名</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">float</span> hp; <span class="comment">//血量</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">float</span> armor; <span class="comment">//护甲</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">int</span> moveSpeed; <span class="comment">//移动速度</span></span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span></span>;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//与匿名类的区别在于，本地类有了自定义的类名</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">SomeHero</span> <span class="keyword">extends</span> <span class="title">Hero</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println( name+ <span class="string">&quot; 新的进攻手段&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        SomeHero h  =<span class="keyword">new</span> SomeHero();</span><br><span class="line">        h.name =<span class="string">&quot;地卜师&quot;</span>;</span><br><span class="line">        h.attack();</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>默认方法是JDK8新特性，指的是接口也可以提供具体方法了，而不像以前，只能提供抽象方法</p>
<p>Mortal 这个接口，增加了一个<strong>默认方法</strong> revive，这个方法有实现体，并且被声明为了<strong>default</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mortal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">die</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;本英雄复活了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么要有默认方法？</p>
</blockquote>
<p>假设没有默认方法这种机制，那么如果要为Mortal增加一个新的方法revive,那么所有实现了Mortal接口的类，都需要做改动。</p>
<p>但是引入了默认方法后，原来的类，不需要做任何改动，并且还能<strong>得到</strong>这个默认方法</p>
<p>通过这种手段，就能够很好的扩展新的类，并且做到不影响原来的类</p>
<h1 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h1><h2 id="封装类"><a href="#封装类" class="headerlink" title="封装类"></a>封装类</h2><p>所有的<strong>基本类型</strong>，都有对应的<strong>类类型</strong><br>比如int对应的类是Integer<br>这种类就叫做封装类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> digit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNumber</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//把一个基本类型的变量,转换为Integer对象</span></span><br><span class="line">        Integer it = <span class="keyword">new</span> Integer(i);</span><br><span class="line">        <span class="comment">//把一个Integer对象，转换为一个基本类型的int</span></span><br><span class="line">        <span class="keyword">int</span> i2 = it.intValue();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h2><p>数字封装类有<br>Byte,Short,Integer,Long,Float,Double<br>这些类都是抽象类Number的子类</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200810191952313.png" alt="image-20200810191952313"></p>
<h2 id="自动装箱-拆箱"><a href="#自动装箱-拆箱" class="headerlink" title="自动装箱/拆箱"></a>自动装箱/拆箱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer it = <span class="keyword">new</span> Integer(i);       </span><br><span class="line"><span class="comment">//封装类型转换成基本类型</span></span><br><span class="line"><span class="keyword">int</span> i2 = it.intValue();</span><br><span class="line"></span><br><span class="line">Integer it = <span class="keyword">new</span> Integer(i);</span><br><span class="line"><span class="comment">//自动转换就叫装箱</span></span><br><span class="line">Integer it2 = i;</span><br></pre></td></tr></table></figure>

<h2 id="int的最大值，最小值"><a href="#int的最大值，最小值" class="headerlink" title="int的最大值，最小值"></a>int的最大值，最小值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MAX_VALUE);</span><br><span class="line"><span class="comment">//int的最小值      </span></span><br><span class="line">System.out.println(Integer.MIN_VALUE);</span><br></pre></td></tr></table></figure>

<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>StringBuffer是可变长的字符串</p>
<p>append追加<br>delete 删除<br>insert 插入<br>reverse 反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> character;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;let there &quot;</span>;</span><br><span class="line"> </span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer(str1); <span class="comment">//根据str1创建一个StringBuffer对象</span></span><br><span class="line">        sb.append(<span class="string">&quot;be light&quot;</span>); <span class="comment">//在最后追加</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(sb);</span><br><span class="line">         </span><br><span class="line">        sb.delete(<span class="number">4</span>, <span class="number">10</span>);<span class="comment">//删除4-10之间的字符</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(sb);</span><br><span class="line">         </span><br><span class="line">        sb.insert(<span class="number">4</span>, <span class="string">&quot;there &quot;</span>);<span class="comment">//在4这个位置插入 there</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(sb);</span><br><span class="line">         </span><br><span class="line">        sb.reverse(); <span class="comment">//反转</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(sb);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么StringBuffer可以变长？<br>和String<strong>内部是一个字符数组</strong>一样，StringBuffer也维护了一个字符数组。 但是，这个字符数组，<strong>留有冗余长度</strong><br>比如说new StringBuffer(“the”)，其内部的字符数组的长度，是19，而不是3，这样调用插入和追加，在现成的数组的基础上就可以完成了。<br>如果追加的长度超过了19，就会分配一个新的数组，长度比原来多一些，把原来的数据复制到新的数组中，<strong>看上去</strong> 数组长度就变长了 参考<a target="_blank" rel="noopener" href="https://how2j.cn/k/number-string/number-string-mystringbuilder/331.html">MyStringBuffer</a><br>length: “the”的长度 3<br>capacity: 分配的总空间 19</p>
<p><strong>注：</strong> 19这个数量，不同的JDK数量是不一样的</p>
</blockquote>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><h3 id="日期转字符串"><a href="#日期转字符串" class="headerlink" title="日期转字符串"></a>日期转字符串</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200810214431100.png" alt="image-20200810214431100"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> date;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDate</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//y 代表年</span></span><br><span class="line">        <span class="comment">//M 代表月</span></span><br><span class="line">        <span class="comment">//d 代表日</span></span><br><span class="line">        <span class="comment">//H 代表24进制的小时</span></span><br><span class="line">        <span class="comment">//h 代表12进制的小时</span></span><br><span class="line">        <span class="comment">//m 代表分钟</span></span><br><span class="line">        <span class="comment">//s 代表秒</span></span><br><span class="line">        <span class="comment">//S 代表毫秒</span></span><br><span class="line">        SimpleDateFormat sdf =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span> );</span><br><span class="line">        Date d= <span class="keyword">new</span> Date();</span><br><span class="line">        String str = sdf.format(d);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间通过 yyyy-MM-dd HH:mm:ss SSS 格式化后的输出: &quot;</span>+str);</span><br><span class="line">         </span><br><span class="line">        SimpleDateFormat sdf1 =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span> );</span><br><span class="line">        Date d1= <span class="keyword">new</span> Date();</span><br><span class="line">        String str1 = sdf1.format(d1);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间通过 yyyy-MM-dd 格式化后的输出: &quot;</span>+str1);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串转日期"><a href="#字符串转日期" class="headerlink" title="字符串转日期"></a>字符串转日期</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200810214709792.png" alt="image-20200810214709792"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> date;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDate</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span> );</span><br><span class="line">  </span><br><span class="line">        String str = <span class="string">&quot;2016/1/5 12:12:12&quot;</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date d = sdf.parse(str);</span><br><span class="line">            System.out.printf(<span class="string">&quot;字符串 %s 通过格式  yyyy/MM/dd HH:mm:ss %n转换为日期对象: %s&quot;</span>,str,d.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常处理常见手段： try catch finally throws</p>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        File f= <span class="keyword">new</span> File(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">            e.printStackTrace(); <span class="comment">//会打印出方法的调用痕迹</span></span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常的父类catch"><a href="#异常的父类catch" class="headerlink" title="异常的父类catch"></a>异常的父类catch</h3><p>FileNotFoundException是Exception的子类，使用Exception也可以catch住FileNotFoundException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多异常捕捉方法"><a href="#多异常捕捉方法" class="headerlink" title="多异常捕捉方法"></a>多异常捕捉方法</h3><ol>
<li><p>多个catch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;日期格式解析错误&quot;</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只写一个catch</p>
<p>好处是捕捉的代码<strong>更紧凑</strong>，不足之处是，一旦发生异常，<strong>不能确定到底是哪种异常</strong>，需要通过instanceof 进行判断具体的异常类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (FileNotFoundException | ParseException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FileNotFoundException)</span><br><span class="line">                System.out.println(<span class="string">&quot;d:/LOL.exe不存在&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ParseException)</span><br><span class="line">                System.out.println(<span class="string">&quot;日期格式解析错误&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>无论是否出现异常，finally中的代码都会被执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;无论文件是否存在， 都会执行的代码&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h3><p>method2中需要进行异常处理<br>但是method2<strong>不打算处理</strong>，而是把这个异常通过<strong>throws**</strong>抛出去**<br>那么method1就会<strong>接到该异常</strong>。 处理办法也是两种，要么是try catch处理掉，要么也是<strong>抛出去</strong>。<br>method1选择本地try catch住 一旦try catch住了，就相当于把这个异常消化掉了，主方法在调用method1的时候，就不需要进行异常处理了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method1();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/LOL.exe&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;试图打开 d:/LOL.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        System.out.println(<span class="string">&quot;成功打开&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别"></a>throw和throws的区别</h3><p>throws与throw这两个关键字接近，不过意义不一样，有如下区别：</p>
<ol>
<li>throws 出现在方法声明上，而throw通常都出现在方法体内。</li>
<li>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某个异常对象。</li>
</ol>
<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p>异常分类： 可查异常，运行时异常和错误3种<br>其中，运行时异常和错误又叫非可查异常</p>
<h3 id="可查异常"><a href="#可查异常" class="headerlink" title="可查异常"></a>可查异常</h3><p>可查异常： CheckedException<br>可查异常即<strong>必须进行处理的异常</strong>，要么try catch住,要么往外抛，谁调用，谁处理，比如 FileNotFoundException<br>如果不处理，编译器，就不让你通过</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200811204439616.png" alt="image-20200811204439616"></p>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>运行时异常RuntimeException指： <strong>不是必须进行try catch的异常</strong><br><strong>常见运行时异常:</strong><br>除数不能为0异常:ArithmeticException<br>下标越界异常:ArrayIndexOutOfBoundsException<br>空指针异常:NullPointerException<br>在编写代码的时候，依然可以使用try catch throws进行处理，与可查异常不同之处在于，<strong>即便不进行try catch，也不会有编译错误</strong><br>Java之所以会设计运行时异常的原因之一，是因为下标越界，空指针这些运行时异常<strong>太过于普遍</strong>，如果都需要进行捕捉，代码的可读性就会变得很糟糕。</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>错误Error，指的是<strong>系统级别的异常</strong>，通常是内存用光了<br>在<strong>默认设置下</strong>，一般java程序启动的时候，最大可以使用16m的内存<br>如例不停的给StringBuffer追加字符，很快就把内存使用光了。抛出<strong>OutOfMemoryError</strong><br>与运行时异常一样，错误也是不要求强制捕捉的</p>
<h3 id><a href="#" class="headerlink" title></a><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200811204843992.png" alt="image-20200811204843992"></h3><h2 id="运行时异常与非运行时异常的区别"><a href="#运行时异常与非运行时异常的区别" class="headerlink" title="运行时异常与非运行时异常的区别"></a>运行时异常与非运行时异常的区别</h2><blockquote>
<p>面试常问题：运行时异常与非运行时异常的区别？</p>
</blockquote>
<p>答：运行时错误是RunTimeException类或其子类，一般是由程序逻辑问题引起的，如果不进行异常处理，线程或程序将在问题处中断（或main函数处中断）;  非运行错误是RunTimeException以外的异常，类型上都属于Exception类及其子类，java编辑器要求必须对这类异常进行处理</p>
<h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>Throwable是类，Exception和Error都继承了该类<br>所以在捕捉的时候，也可以使用Throwable进行捕捉<br>如图： 异常分<strong>Error</strong>和<strong>Exception</strong><br>Exception里又分<strong>运行时异常</strong>和<strong>可查异常</strong>。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200811210452014.png" alt="image-20200811210452014"></p>
<h2 id="创建自定义异常"><a href="#创建自定义异常" class="headerlink" title="创建自定义异常"></a>创建自定义异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnemyHeroIsDeadException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><p>绝对路经<br><code>File f1 = new File(&quot;d:/LOLFolder&quot;);</code></p>
<p>相对路径<br><code>File f2 = new File(&quot;LOL.exe&quot;);</code></p>
<p>指定父目录<br><code>File f3 = new File(f1, &quot;LOL.exe&quot;);</code></p>
<p>可菜鸟教程查看文件的操作方法，比如<code>f.exists()</code> <code>f.isDirectort()</code> <code>f.isFile</code></p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>当不同的介质之间有数据交互的时候，JAVA就使用流来实现。<br>数据源可以是文件，还可以是数据库，网络甚至是其他的程序<br>什么是流(Stream)，流就是一系列的数据</p>
<p><strong>流关系图</strong></p>
<ol>
<li>流分为字节流和字符流</li>
<li>字节流下面常用的又有数据流和对象流</li>
<li>字符流下面常用的又有缓存流</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200812213731126.png" alt="image-20200812213731126"></p>
<p>输入流： InputStream<br>输出流：OutputStream</p>
<p>创建输入流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 创建基于文件的输入流</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="keyword">byte</span>[] all =<span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line"><span class="comment">//以字节流的形式读取文件所有内容</span></span><br><span class="line">fis.read(all);</span><br><span class="line">fis.close;</span><br></pre></td></tr></table></figure>

<p>关闭输入流</p>
<ol>
<li><p>在try中关闭</p>
<p>在try的作用域里关闭文件输入流，在前面的示例中都是使用这种方式，这样做有一个弊端；<br>如果文件不存在，或者读取的时候出现问题而抛出异常，那么就不会执行这一行关闭流的代码，存在巨大的资源占用隐患。 <strong>不推荐</strong>使用</p>
</li>
<li><p>在finall中关闭</p>
<p>这是标准的关闭流的方式<br>\1. 首先把流的引用声明在try的外面，如果声明在try里面，其作用域无法抵达finally.<br>\2. 在finally关闭之前，要先判断该引用是否为空<br>\3. 关闭的时候，需要再一次进行try catch处理</p>
<p>这是标准的严谨的关闭流的方式，但是看上去很繁琐，所以写不重要的或者测试代码的时候，都会采用上面的<strong>有隐患</strong>try的方式，因为不麻烦~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            <span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : all) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在finally 里关闭流</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != fis)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用try()的方式</p>
<p>把流定义在try()里,try,catch或者finally结束的时候，会自动关闭<br>这种编写代码的方式叫做 <strong>try-with-resources</strong>， 这是从JDK7开始支持的技术</p>
<p>所有的流，都实现了一个接口叫做 <strong>AutoCloseable</strong>，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//把流定义在try()里,try,catch或者finally结束的时候，会自动关闭</span></span><br><span class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(f)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] all = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) f.length()];</span><br><span class="line">            fis.read(all);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">byte</span> b : all) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>字符流</p>
<p>FileReader字符输入流<br>FileWriter字符输出流<br>专门用于字符的形式读取和写入数据<br>读出来的就是字符char</p>
<h2 id="中文问题"><a href="#中文问题" class="headerlink" title="中文问题"></a>中文问题</h2><p>工作后经常接触的编码方式有如下几种：<br><strong>ISO-8859-1 ASCII</strong> 数字和西欧字母<br><strong>GBK GB2312 BIG5</strong> 中文<br><strong>UNICODE</strong> (统一码，万国码)</p>
<p>ISO-8859-1 包含 ASCII<br>GB2312 是简体中文，BIG5是繁体中文，GBK同时包含简体和繁体以及日文。<br>UNICODE 包括了所有的文字，无论中文，英文，藏文，法文，世界所有的文字都包含其中</p>
<p>如果完全按照UNICODE的方式来存储数据，就会有很大的浪费。<br>比如在ISO-8859-1中，<strong>a</strong> 字符对应的数字是0x61<br>而UNICODE中对应的数字是 0x00000061，倘若一篇文章大部分都是英文字母，那么按照UNICODE的方式进行数据保存就会消耗很多空间</p>
<p>在这种情况下，就出现了UNICODE的各种<strong>减肥</strong>子编码, 比如UTF-8对数字和字母就使用一个字节，而对汉字就使用3个字节，从而达到了<strong>减肥还能保证健康</strong>的效果</p>
<p>UTF-8，UTF-16和UTF-32 针对不同类型的数据有不同的<strong>减肥效果</strong>，一般说来UTF-8是比较常用的方式</p>
<blockquote>
<p>java采用的是Unicode</p>
</blockquote>
<h2 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h2><p>缓存流在读取的时候，<strong>会一次性读较多的数据到缓存中</strong>，以后每一次的读取，都是在缓存中访问，直到缓存中的数据读取完毕，再到硬盘中读取。</p>
<p>缓存流在写入数据的时候，会先把数据写入到缓存区，直到缓存区<strong>达到一定的量</strong>，才把这些数据，<strong>一起写入到硬盘中去</strong>。按照这种操作模式，就不会像字节流，字符流那样<strong>每写一个字节都访问硬盘</strong>，从而减少了IO操作</p>
<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>缓存字符输入流 BufferedReader 可以一次读取一行数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/lol.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 创建文件字符流</span></span><br><span class="line"><span class="comment">// 缓存流必须建立在一个存在的流的基础上</span></span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    FileReader fr = <span class="keyword">new</span> FileReader(f);</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">)</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h3><p>PrintWriter 缓存字符输出流， 可以一次写出一行数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向文件lol2.txt中写入三行语句</span></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;d:/lol2.txt&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建文件字符流</span></span><br><span class="line">                FileWriter fw = <span class="keyword">new</span> FileWriter(f);</span><br><span class="line">                <span class="comment">// 缓存流必须建立在一个存在的流的基础上              </span></span><br><span class="line">                PrintWriter pw = <span class="keyword">new</span> PrintWriter(fw);              </span><br><span class="line">        ) &#123;</span><br><span class="line">            pw.println(<span class="string">&quot;garen kill teemo&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;teemo revive after 1 minutes&quot;</span>);</span><br><span class="line">            pw.println(<span class="string">&quot;teemo try to garen, but killed again&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h3><p>有的时候，需要<strong>立即把数据写入到硬盘</strong>，而不是等缓存满了才写出去。 这时候就需要用到flush</p>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>DataInputStream 数据输入流<br>DataOutputStream 数据输出流</p>
<p>使用数据流的writeUTF()和readUTF() 可以进行数据的<strong>格式化顺序读写</strong><br>如本例，通过DataOutputStream 向文件顺序写出 布尔值，整数和字符串。 然后再通过DataInputStream 顺序读入这些数据。<br><strong>注：</strong> 要用DataInputStream 读取一个文件，这个文件必须是由DataOutputStream 写出的，否则会出现EOFException，因为DataOutputStream 在写出的时候会做一些特殊标记，只有DataInputStream 才能成功的读取。</p>
<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>对象流指的是可以直接<strong>把一个对象以流的形式</strong>传输给其他的介质，比如硬盘</p>
<p>一个对象以流的形式进行传输，叫做序列化。 该对象所对应的类，必须是实现Serializable接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示这个类当前的版本，如果有了变化，比如新设计了属性，就应该修改这个版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> hp;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stream;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStream</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个Hero garen</span></span><br><span class="line">        <span class="comment">//要把Hero对象直接保存在文件上，务必让Hero类实现Serializable接口</span></span><br><span class="line">        Hero h = <span class="keyword">new</span> Hero();</span><br><span class="line">        h.name = <span class="string">&quot;garen&quot;</span>;</span><br><span class="line">        h.hp = <span class="number">616</span>;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//准备一个文件用于保存该对象</span></span><br><span class="line">        File f =<span class="keyword">new</span> File(<span class="string">&quot;d:/garen.lol&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>(</span><br><span class="line">            <span class="comment">//创建对象输出流</span></span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">            ObjectOutputStream oos =<span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">            <span class="comment">//创建对象输入流              </span></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">            ObjectInputStream ois =<span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">        ) &#123;</span><br><span class="line">            oos.writeObject(h);</span><br><span class="line">            Hero h2 = (Hero) ois.readObject();</span><br><span class="line">            System.out.println(h2.name);</span><br><span class="line">            System.out.println(h2.hp);</span><br><span class="line">               </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p>数组有局限性，声明长度为10，用不完的浪费，超过了又不可以</p>
<p>为了解决数组的局限性，引入容器类的概念。 最常见的容器类就是ArrayList，容器的容量“Capacity”会随着对象的增加 自动增长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//容器类ArrayList，用于存放对象</span></span><br><span class="line">        ArrayList heros = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        heros.add( <span class="keyword">new</span> Hero(<span class="string">&quot;盖伦&quot;</span>));</span><br><span class="line">        System.out.println(heros.size());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//容器的容量&quot;capacity&quot;会随着对象的增加，自动增长</span></span><br><span class="line">        <span class="comment">//只需要不断往容器里增加英雄即可，不用担心会出现数组的边界问题。</span></span><br><span class="line">        heros.add( <span class="keyword">new</span> Hero(<span class="string">&quot;提莫&quot;</span>));</span><br><span class="line">        System.out.println(heros.size());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList实现了接口List<br>常见的写法会把引用声明为接口List类型<br><code>List heros = ``new</code> <code>ArrayList();</code></p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200815104529255.png" alt="image-20200815104529255"></p>
<p><strong>toArray()</strong></p>
<p><strong>toArray</strong>可以把一个ArrayList对象转换为数组。<br>需要注意的是，如果要转换为一个Hero数组，那么需要传递一个Hero数组类型的对象给toArray()，这样toArray方法才知道，你希望转换为哪种类型的数组，否则只能转换为Object数组。<br><code>Hero hs[] = (Hero[])heros.toArray(**new Hero[]&#123;&#125;**);</code></p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>不指定泛型的容器，可以存放任何类型的元素<br><code>List heros = ``new</code> <code>ArrayList();</code></p>
<p>指定了泛型的容器，只能存放指定类型的元素以及其子类<br><code>List&lt;Hero&gt; genericheros = ``new</code> <code>ArrayList&lt;Hero&gt;();</code></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol>
<li><p>for遍历</p>
<p>通过size()获得集合大小，再通过for循环，get()到ArrayList的内容输出。</p>
</li>
<li><p>迭代器遍历</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200815110538476.png" alt="image-20200815110538476"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Hero&gt; it= heros.iterator();</span><br><span class="line"><span class="comment">//从最开始的位置判断&quot;下一个&quot;位置是否有数据</span></span><br><span class="line"><span class="comment">//如果有就通过next取出来，并且把指针向下移动</span></span><br><span class="line"><span class="comment">//直到&quot;下一个&quot;位置没有数据</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    Hero h = it.next();</span><br><span class="line">    System.out.println(h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器的for写法</span></span><br><span class="line">System.out.println(<span class="string">&quot;--------使用for的iterator-------&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;Hero&gt; iterator = heros.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">    Hero hero = (Hero) iterator.next();</span><br><span class="line">    System.out.println(hero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增强型for循环</strong></p>
<p>使用增强型for循环可以非常方便的遍历ArrayList中的元素，这是很多开发人员的首选。</p>
<p>不过增强型for循环也有不足：<br>无法用来进行ArrayList的初始化<br>无法得知当前是第几个元素了，当需要只打印单数元素的时候，就做不到了。 必须再自定下标变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Hero h : heros) &#123;</span><br><span class="line">    System.out.println(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>与<a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-arraylist-method/685.html">ArrayList</a>一样，LinkedList也实现了List接口，诸如add,remove,contains等等方法。而且还实现了Queue接口（队列）。</p>
<p>除了实现了List接口外，LinkedList还实现了<strong>双向链表结构</strong>Deque，可以很方便的在头尾插入删除数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在最后插入新的英雄</span></span><br><span class="line">ll.addLast(<span class="keyword">new</span> Hero(<span class="string">&quot;hero1&quot;</span>));</span><br><span class="line"><span class="comment">//在最前面插入新的英雄</span></span><br><span class="line">ll.addFirst(<span class="keyword">new</span> Hero(<span class="string">&quot;heroX&quot;</span>));</span><br><span class="line"><span class="comment">//查看最前面的英雄</span></span><br><span class="line">System.out.println(ll.getFirst());</span><br><span class="line"><span class="comment">//查看最后面的英雄</span></span><br><span class="line">System.out.println(ll.getLast());</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>大部分与ArrayList相同，且实现了队列的方法</p>
<ul>
<li><strong>offer</strong> 在最后添加元素</li>
<li><strong>poll</strong> 取出第一个元素</li>
<li><strong>peek</strong> 查看第一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和ArrayList一样，LinkedList也实现了List接口</span></span><br><span class="line">List ll =<span class="keyword">new</span> LinkedList&lt;Hero&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//所不同的是LinkedList还实现了Deque，进而又实现了Queue这个接口</span></span><br><span class="line"><span class="comment">//Queue代表FIFO 先进先出的队列</span></span><br><span class="line">Queue&lt;Hero&gt; q= <span class="keyword">new</span> LinkedList&lt;Hero&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap储存数据的方式是—— 键值对 Key-Value</p>
<p><strong>键不能重复，值可以重复</strong></p>
<p><code>HashMap&lt;String,String&gt; dictionary = ``new</code> <code>HashMap&lt;&gt;();</code></p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><strong>Set中的元素，不能重复</strong></p>
<p><code>HashSet&lt;String&gt; names = ``new</code> <code>HashSet&lt;String&gt;();</code></p>
<p><strong>Set中的元素，没有顺序。</strong><br>严格的说，是没有按照元素的插入顺序排列</p>
<p>HashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。关于hashcode有专门的章节讲解: <a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-hashcode/371.html">hashcode 原理</a>。</p>
<p><strong>遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; numbers = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            numbers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//Set不提供get方法来获取指定位置的元素</span></span><br><span class="line">        <span class="comment">//numbers.get(0)</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//遍历Set可以采用迭代器iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Integer&gt; iterator = numbers.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">            Integer i = (Integer) iterator.next();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//或者采用增强型for循环</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : numbers) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashSet和HashMap的关系"><a href="#HashSet和HashMap的关系" class="headerlink" title="HashSet和HashMap的关系"></a>HashSet和HashMap的关系</h2><p>通过观察HashSet的源代码<br>可以发现HashSet自身并没有独立的实现，而是在里面封装了一个Map.<br>HashSet是作为Map的key而存在的<br>而value是一个命名为PRESENT的static的Object对象，因为是一个类属性，所以只会有一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.AbstractSet;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//HashSet里封装了一个HashMap</span></span><br><span class="line">    <span class="keyword">private</span>  HashMap&lt;E,Object&gt; map;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//HashSet的构造方法初始化这个HashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//向HashSet中增加元素，其实就是把该元素作为key，增加到Map中</span></span><br><span class="line">    <span class="comment">//value是PRESENT，静态，final的对象，所有的HashSet都使用这么同一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//HashSet的size就是map的size</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//清空Set就是清空Map</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//迭代Set,就是把Map的键拿出来迭代</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection是一个接口</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200815143041917.png" alt="image-20200815143041917"></p>
<p>Collection是 Set List Queue和 Deque的接口<br>Queue: 先进先出队列<br>Deque: 双向链表</p>
<p><strong>注：</strong>Collection和Map之间没有关系，Collection是放一个一个对象的，Map 是放键值对的<br><strong>注：</strong>Deque 继承 Queue,间接的继承了 Collection</p>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>Collections是一个类，容器的工具类,就如同Arrays是数组的工具类</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200815143425302.png" alt="image-20200815143425302"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//reverse() 使List中的数据发生翻转</span></span><br><span class="line">Collections.reverse(numbers);</span><br><span class="line"><span class="comment">//shuffle 混淆List中数据的顺序</span></span><br><span class="line">Collections.shuffle(numbers);</span><br><span class="line"><span class="comment">//sort 对List中的数据进行排序</span></span><br><span class="line">Collections.sort(numbers);</span><br><span class="line"><span class="comment">//swap 交换两个数据的位置</span></span><br><span class="line">Collections.swap(numbers,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//rotate 把List中的数据，向右滚动指定单位的长度</span></span><br><span class="line">Collections.rotate(numbers,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//synchronizedList 把非线程安全的List转换为线程安全的List</span></span><br><span class="line">List&lt;Integer&gt; synchronizedNumbers = (List&lt;Integer&gt;) Collections.synchronizedList(numbers);</span><br></pre></td></tr></table></figure>

<h2 id="ArrayList-vs-HashSet"><a href="#ArrayList-vs-HashSet" class="headerlink" title="ArrayList vs HashSet"></a>ArrayList vs HashSet</h2><p>ArrayList: 有顺序<br>HashSet: 无顺序</p>
<p>List中的数据可以重复<br>Set中的数据不能够重复</p>
<p>HashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。</p>
<h2 id="HashMap-vs-HashTable"><a href="#HashMap-vs-HashTable" class="headerlink" title="HashMap vs HashTable"></a>HashMap vs HashTable</h2><p>HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式<br>区别1：<br>HashMap可以存放 null<br>Hashtable不能存放null<br>区别2：<br>HashMap不是<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-synchronized/355.html#step793">线程安全的类</a><br>Hashtable是线程安全的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式</span></span><br><span class="line">         </span><br><span class="line">        HashMap&lt;String,String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//HashMap可以用null作key,作value</span></span><br><span class="line">        hashMap.put(<span class="keyword">null</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;123&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">         </span><br><span class="line">        Hashtable&lt;String,String&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;String,String&gt;();</span><br><span class="line">        <span class="comment">//Hashtable不能用null作key，不能用null作value</span></span><br><span class="line">        hashtable.put(<span class="keyword">null</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        hashtable.put(<span class="string">&quot;123&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="几种Set"><a href="#几种Set" class="headerlink" title="几种Set"></a>几种Set</h2><p>HashSet： 无序<br>LinkedHashSet： 按照插入顺序<br>TreeSet： 从小到大排序</p>
<h2 id="hashcode的原理"><a href="#hashcode的原理" class="headerlink" title="hashcode的原理"></a>hashcode的原理</h2><p><strong>—–hashcode概念—–</strong><br>所有的对象，都有一个对应的<strong>hashcode（散列值）</strong><br>比如字符串“gareen”对应的是1001 (实际上不是，这里是方便理解，假设的值)<br>比如字符串“temoo”对应的是1004<br>比如字符串“db”对应的是1008<br>比如字符串“annie”对应的<strong>也**</strong>是1008**</p>
<p><strong>—–保存数据—–</strong><br>准备一个数组，其长度是2000，并且设定特殊的hashcode算法，使得所有字符串对应的hashcode，都会落在0-1999之间<br>要存放名字是”gareen”的英雄，就把该英雄和名称组成一个<strong>键值对</strong>，存放在数组的1001这个位置上<br>要存放名字是”temoo”的英雄，就把该英雄存放在数组的1004这个位置上<br>要存放名字是”db”的英雄，就把该英雄存放在数组的1008这个位置上<br>要存放名字是”annie”的英雄，然而 “annie”的hashcode 1008对应的位置<strong>已经有db英雄了</strong>，那么就在这里创建一个链表，<strong>接在db英雄后面存放annie</strong></p>
<p><strong>—–查找数据—–</strong><br>比如要查找gareen，首先计算”gareen”的hashcode是1001，根据1001这个下标，到数组中进行定位，（<strong>根据数组下标进行定位，是非常快速的</strong>） 发现1001这个位置就只有一个英雄，那么该英雄就是gareen.<br>比如要查找annie，首先计算”annie”的hashcode是1008，根据1008这个下标，到数组中进行定位，发现1008这个位置<strong>有两个英雄</strong>，那么就对两个英雄的名字进行逐一比较(<strong>equals</strong>)，因为此时需要比较的量就已经少很多了，很快也就可以找出目标英雄<br>这就是使用hashmap进行查询，非常快原理。</p>
<p>这是一种用<strong>空间换时间</strong>的思维方式</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200815153314500.png" alt="image-20200815153314500"></p>
<p><strong>HashSet判断是否重复</strong></p>
<p>HashSet的数据是不能重复的，相同数据不能保存在一起，到底如何判断是否是重复的呢？<br>根据<a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-hashset/364.html#step825">HashSet和HashMap的关系</a>，我们了解到因为HashSet没有自身的实现，而是里面封装了一个HashMap，所以本质上就是判断HashMap的key是否重复。</p>
<p>再通过上一步的学习，key是否重复，是由两个步骤判断的：<br>hashcode是否一样<br>如果hashcode不一样，就是在<strong>不同的坑里</strong>，一定是不重复的<br>如果hashcode一样，就是在<strong>同一个坑里</strong>，还需要进行equals比较<br>如果equals一样，则是重复数据<br>如果equals不一样，则是不同数据。</p>
<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p><strong>指定对象里要比价的那个值</strong></p>
<p>假设Hero有三个属性 name,hp,damage<br>一个集合中放存放10个Hero,通过Collections.sort对这10个进行排序<br>那么<strong>到底是hp小的放前面？还是damage小的放前面？</strong>Collections.sort也无法确定<br>所以要指定到底按照哪种属性进行排序<br>这里就需要提供一个Comparator给定如何进行两个对象之间的<strong>大小</strong>比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collection;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r =<span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//通过随机值实例化hero的hp和damage</span></span><br><span class="line">            heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span>+ i, r.nextInt(<span class="number">100</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//直接调用sort会出现编译错误，因为Hero有各种属性</span></span><br><span class="line">        <span class="comment">//到底按照哪种属性进行比较，Collections也不知道，不确定，所以没法排</span></span><br><span class="line">        <span class="comment">//Collections.sort(heros);</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//引入Comparator，指定比较的算法</span></span><br><span class="line">        Comparator&lt;Hero&gt; c = <span class="keyword">new</span> Comparator&lt;Hero&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Hero h1, Hero h2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//按照hp进行排序</span></span><br><span class="line">                <span class="keyword">if</span>(h1.hp&gt;=h2.hp)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//正数表示h1比h2要大</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Collections.sort(heros,c);</span><br><span class="line">        System.out.println(<span class="string">&quot;按照血量排序后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><p>使Hero类实现Comparable接口<br>在类里面提供比较算法<br>Collections.sort就有足够的信息进行排序了，也无需额外提供比较器Comparator<br><strong>注：</strong> 如果返回-1, 就表示当前的更小，否则就是更大</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> charactor;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Hero</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> hp;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> damage;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">()</span></span>&#123;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name =name;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//初始化name,hp,damage的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hero</span><span class="params">(String name,<span class="keyword">float</span> hp, <span class="keyword">int</span> damage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name =name;</span><br><span class="line">        <span class="keyword">this</span>.hp = hp;</span><br><span class="line">        <span class="keyword">this</span>.damage = damage;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//重写compareTO（)方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Hero anotherHero)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(damage&lt;anotherHero.damage)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero [name=&quot;</span> + name + <span class="string">&quot;, hp=&quot;</span> + hp + <span class="string">&quot;, damage=&quot;</span> + damage + <span class="string">&quot;]\r\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hero类实现了接口Comparable，即自带比较信息。</span></span><br><span class="line"><span class="comment">//Collections直接进行排序，无需额外的Comparator</span></span><br><span class="line">Collections.sort(heros);</span><br></pre></td></tr></table></figure>

<h1 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h1><p><strong>不使用泛型带来的问题</strong>：<br>ADHero（物理攻击英雄） APHero（魔法攻击英雄）都是Hero的子类<br>ArrayList 默认接受Object类型的对象，所以所有对象都可以放进ArrayList中<br>所以get(0) <strong>返回的类型是Object</strong><br>接着，需要进行强制转换才可以得到APHero类型或者ADHero类型。<br>如果软件开发人员记忆比较好，能<strong>记得哪个是哪个</strong>，还是可以的。 但是开发人员会犯错误，比如第20行，会记错，把第0个对象转换为ADHero,这样就会出现类型转换异常</p>
<p><strong>使用泛型的好处：</strong><br>泛型的用法是在容器后面添加<Type><br>Type可以是类，抽象类，接口<br>泛型表示这种容器，<strong>只能存放APHero</strong>，ADHero就放不进去了。</Type></p>
<p>假设容器的泛型是Hero,那么<strong>Hero的子类</strong>APHero,ADHero<strong>都可以放进去</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> charactor.APHero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;APHero&gt; heros = <span class="keyword">new</span> ArrayList&lt;APHero&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//只有APHero可以放进去    </span></span><br><span class="line">        heros.add(<span class="keyword">new</span> APHero());</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//ADHero甚至放不进去</span></span><br><span class="line">        <span class="comment">//heros.add(new ADHero());</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//获取的时候也不需要进行转型，因为取出来一定是APHero</span></span><br><span class="line">        APHero apHero =  heros.get(<span class="number">0</span>);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="支持泛型的类"><a href="#支持泛型的类" class="headerlink" title="支持泛型的类"></a>支持泛型的类</h2><p>跟面向对象差不多，如果不支持泛型，我得每次创建一个支持Hero对象的类，一个支持Item对象的类，如果支持泛型，设计类的时候，在类声明上加上<T>：</T></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;T&gt; values = <span class="keyword">new</span> LinkedList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        values.addLast(t);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以后初始化的时候<br><code>MyStack&lt;Hero&gt; heroStack = ``new</code> <code>MyStack&lt;&gt;();</code><br><code>MyStack&lt;Item&gt; itemStack = ``new</code> <code>MyStack&lt;&gt;();</code></p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p><strong>总结：</strong></p>
<ul>
<li>如果希望只取出，不插入，就使用? extends Hero</li>
<li>如果希望只插入，不取出，就使用? super Hero</li>
<li>如果希望，又能插入，又能取出，就不要用通配符？</li>
</ul>
<h3 id="extends"><a href="#extends" class="headerlink" title="? extends"></a>? extends</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200815164927133.png" alt="image-20200815164927133"></p>
<blockquote>
<p>泛型里面放泛型</p>
</blockquote>
<p>ArrayList heroList&lt;? extends Hero&gt; 表示这是一个Hero泛型或者其子类泛型<br>heroList 的泛型可能是Hero<br>heroList 的泛型可能是APHero<br>heroList 的泛型可能是ADHero<br>所以 可以确凿的是，<strong>从heroList取出来的对象，一定是可以转型成Hero的</strong></p>
<p>但是，不能往里面放东西，因为<br>放APHero就不满足<ADHero><br>放ADHero又不满足<APHero></APHero></ADHero></p>
<h3 id="super"><a href="#super" class="headerlink" title="? super"></a>? super</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200815165045149.png" alt="image-20200815165045149"></p>
<p>ArrayList heroList&lt;? super Hero&gt; 表示这是一个Hero泛型或者其父类泛型<br>heroList的泛型可能是Hero<br>heroList的泛型可能是Object</p>
<p><strong>可以往里面插入Hero以及Hero的子类</strong><br>但是取出来有风险，因为不确定取出来是Hero还是Object</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> charactor.ADHero;</span><br><span class="line"><span class="keyword">import</span> charactor.APHero;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;? <span class="keyword">super</span> Hero&gt; heroList = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//? super Hero 表示 heroList的泛型是Hero或者其父类泛型</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Hero</span></span><br><span class="line">        <span class="comment">//heroList 的泛型可以是Object</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">//所以就可以插入Hero</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> Hero());</span><br><span class="line">        <span class="comment">//也可以插入Hero的子类</span></span><br><span class="line">        heroList.add(<span class="keyword">new</span> APHero());</span><br><span class="line">        heroList.add(<span class="keyword">new</span> ADHero());</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//但是，不能从里面取数据出来,因为其泛型可能是Object,而Object是强转Hero会失败</span></span><br><span class="line">        Hero h= heroList.get(<span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符?"></a>泛型通配符?</h3><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200815165645199.png" alt="image-20200815165645199"></p>
<p>泛型通配符? 代表任意泛型<br>既然?代表任意泛型，那么换句话说，这个容器什么泛型都有可能</p>
<p>所以只能以Object的形式取出来<br>并且不能往里面放对象，因为不知道到底是一个什么泛型的容器</p>
<blockquote>
<p>什么意思没太看懂</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> property.Item;</span><br><span class="line"><span class="keyword">import</span> charactor.APHero;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;APHero&gt; apHeroList = <span class="keyword">new</span> ArrayList&lt;APHero&gt;();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//?泛型通配符，表示任意泛型</span></span><br><span class="line">        ArrayList&lt;?&gt; generalList = apHeroList;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//?的缺陷1： 既然?代表任意泛型，那么换句话说，你就不知道这个容器里面是什么类型</span></span><br><span class="line">        <span class="comment">//所以只能以Object的形式取出来</span></span><br><span class="line">        Object o = generalList.get(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//?的缺陷2： 既然?代表任意泛型，那么既有可能是Hero,也有可能是Item</span></span><br><span class="line">        <span class="comment">//所以，放哪种对象进去，都有风险，结果就什么什么类型的对象，都不能放进去</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> Item()); <span class="comment">//编译错误 因为?代表任意泛型，很有可能不是Item</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> Hero()); <span class="comment">//编译错误 因为?代表任意泛型，很有可能不是Hero</span></span><br><span class="line">        generalList.add(<span class="keyword">new</span> APHero()); <span class="comment">//编译错误  因为?代表任意泛型，很有可能不是APHero</span></span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型转换"><a href="#泛型转换" class="headerlink" title="泛型转换"></a>泛型转换</h3><p>面向对象中，子类转父类 是一定可以成功的。<br>泛型中，子类泛型不可以转父类泛型。</p>
<p>假设可以转型成功<br>引用hs指向了ADHero泛型的容器<br>作为Hero泛型的引用hs, 看上去是可以往里面加一个APHero的。<br>但是hs这个引用，实际上是指向的一个ADHero泛型的容器<br>如果能加进去，就变成了ADHero泛型的容器里放进了APHero，这就矛盾了</p>
<p>所以子类泛型<strong>不可以</strong>转换为父类泛型</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200815170717439.png" alt="image-20200815170717439"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> generic;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.ADHero;</span><br><span class="line"><span class="keyword">import</span> charactor.APHero;</span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Hero&gt; hs =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;ADHero&gt; adhs =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//假设能转换成功</span></span><br><span class="line">        hs = adhs;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//作为Hero泛型的hs,是可以向其中加入APHero的</span></span><br><span class="line">        <span class="comment">//但是hs这个引用，实际上是指向的一个ADHero泛型的容器</span></span><br><span class="line">        <span class="comment">//如果能加进去，就变成了ADHero泛型的容器里放进了APHero，这就矛盾了</span></span><br><span class="line">        hs.add(<span class="keyword">new</span> APHero());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Lambda表达式可以看成是匿名类一点点<strong>演变过来</strong></p>
<p>与<a target="_blank" rel="noopener" href="https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687">匿名类</a> 概念相比较，<br>Lambda 其实就是<strong>匿名方法</strong>，这是一种<strong>把方法作为参数</strong>进行传递的编程思想。</p>
<p>虽然代码是这么写</p>
<p>filter(heros, h -&gt; h.hp &gt; 100 &amp;&amp; h.damage &lt; 50);</p>
<p> 但是，Java会在背后，悄悄的，把这些都还原成<a target="_blank" rel="noopener" href="https://how2j.cn/k/lambda/lambda-lamdba-tutorials/697.html#step2552">匿名类方式</a>。<br>引入Lambda表达式，会使得代码更加紧凑，而不是各种接口和匿名类到处飞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLamdba</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化后的集合：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用匿名类的方式，筛选出 hp&gt;100 &amp;&amp; damange&lt;50的英雄&quot;</span>);</span><br><span class="line">        <span class="comment">// 匿名类的正常写法</span></span><br><span class="line">        HeroChecker c1 = <span class="keyword">new</span> HeroChecker() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Hero h)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 把new HeroChcekcer，方法名，方法返回类型信息去掉</span></span><br><span class="line">        <span class="comment">// 只保留方法参数和方法体</span></span><br><span class="line">        <span class="comment">// 参数和方法体之间加上符号 -&gt;</span></span><br><span class="line">        HeroChecker c2 = (Hero h) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 把return和&#123;&#125;去掉</span></span><br><span class="line">        HeroChecker c3 = (Hero h) -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 把 参数类型和圆括号去掉</span></span><br><span class="line">        HeroChecker c4 = h -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 把c4作为参数传递进去</span></span><br><span class="line">        filter(heros, c4);</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 直接把表达式传递进去</span></span><br><span class="line">        filter(heros, h -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;Hero&gt; heros, HeroChecker checker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Hero hero : heros) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checker.test(hero))</span><br><span class="line">                System.out.print(hero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda的弊端</strong></p>
<p>Lambda表达式虽然带来了代码的简洁，但是也有其局限性。</p>
<ol>
<li>可读性差，与<strong>啰嗦的</strong>但是<strong>清晰的</strong>匿名类代码结构比较起来，Lambda表达式一旦变得比较长，就难以理解</li>
<li>不便于调试，很难在Lambda表达式中增加调试信息，比如日志</li>
<li>版本支持，Lambda表达式在JDK8版本中才开始支持，如果系统使用的是以前的版本，考虑系统的稳定性等原因，而不愿意升级，那么就无法使用</li>
</ol>
<p>Lambda比较适合用在简短的业务代码中，并不适合用在复杂的系统中，会加大维护成本。</p>
<h2 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heros</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(h -&gt; h.hp &gt; <span class="number">100</span> &amp;&amp; h.damage &lt; <span class="number">50</span>)</span><br><span class="line">    .forEach(h -&gt; System.out.println(h.name));</span><br></pre></td></tr></table></figure>

<p>要了解聚合操作，首先要建立<strong>Stream</strong>和<strong>管道</strong>的概念<br><strong>Stream</strong> 和Collection结构化的数据不一样，Stream是一系列的元素，就像是生产线上的罐头一样，一串串的出来。<br><strong>管道</strong>指的是一系列的聚合操作。</p>
<p>管道又分3个部分<br><strong>管道源</strong>：在这个例子里，源是一个List<br><strong>中间操作</strong>： 每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。<br><strong>结束操作</strong>：当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回, 结束操作才进行真正的遍历行为，在遍历的时候，才会去进行中间操作的相关判断</p>
<p><strong>注：</strong> 这个Stream和I/O章节的InputStream,OutputStream是不一样的概念。</p>
<p><strong>管道源</strong></p>
<p>把Collection切换成管道源很简单，调用stream()就行了<code>heros.stream()</code><br>但是数组却没有stream()方法，需要使用<code>Arrays.stream(hs)</code><br>或者<code>Stream.of(hs)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAggregate</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//管道源是集合</span></span><br><span class="line">        heros</span><br><span class="line">        .stream()</span><br><span class="line">        .forEach(h-&gt;System.out.println(h.name));</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//管道源是数组</span></span><br><span class="line">        Hero hs[] = heros.toArray(<span class="keyword">new</span> Hero[heros.size()]);</span><br><span class="line">        Arrays.stream(hs)</span><br><span class="line">        .forEach(h-&gt;System.out.println(h.name));</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中间操作</strong></p>
<p>每个中间操作，又会返回一个Stream，比如.filter()又返回一个Stream, 中间操作是“懒”操作，并不会真正进行遍历。<br>中间操作比较多，主要分两类<br>对元素进行筛选 和 转换为其他形式的流<br><strong>对元素进行筛选：</strong><br>filter 匹配<br>distinct 去除重复(根据equals判断)<br>sorted 自然排序<br>sorted(Comparator<T>) 指定排序<br>limit 保留<br>skip 忽略<br><strong>转换为其他形式的流</strong><br>mapToDouble 转换为double的流<br>map 转换为任意类型的流</T></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/2568.png" alt="中间操作"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAggregate</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//制造一个重复数据</span></span><br><span class="line">        heros.add(heros.get(<span class="number">0</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化集合后的数据 (最后一个数据重复)：&quot;</span>);</span><br><span class="line">        System.out.println(heros);</span><br><span class="line">        System.out.println(<span class="string">&quot;满足条件hp&gt;100&amp;&amp;damage&lt;50的数据&quot;</span>);</span><br><span class="line">          </span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(h-&gt;h.hp&gt;<span class="number">100</span>&amp;&amp;h.damage&lt;<span class="number">50</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;去除重复的数据，去除标准是看equals&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .distinct()</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">        System.out.println(<span class="string">&quot;按照血量排序&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted((h1,h2)-&gt;h1.hp&gt;=h2.hp?<span class="number">1</span>:-<span class="number">1</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;保留3个&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .limit(<span class="number">3</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;忽略前3个&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .skip(<span class="number">3</span>)</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;转换为double的Stream&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .mapToDouble(Hero::getHp)</span><br><span class="line">            .forEach(h-&gt;System.out.println(h));</span><br><span class="line">          </span><br><span class="line">        System.out.println(<span class="string">&quot;转换任意类型的Stream&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .map((h)-&gt; h.name + <span class="string">&quot; - &quot;</span> + h.hp + <span class="string">&quot; - &quot;</span> + h.damage)</span><br><span class="line">            .forEach(h-&gt;System.out.println(h));</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>结束操作</strong></p>
<p>当进行结束操作后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 结束操作不会返回Stream，但是会返回int、float、String、 Collection或者像forEach，什么都不返回,。<br>结束操作才真正进行遍历行为，前面的中间操作也在这个时候，才真正的执行。<br>常见结束操作如下：<br><strong>forEach()</strong> 遍历每个元素<br><strong>toArray()</strong> 转换为数组<br><strong>min(Comparator<T>)</T></strong> 取最小的元素<br><strong>max(Comparator<T>)</T></strong> 取最大的元素<br><strong>count()</strong> 总数<br><strong>findFirst()</strong> 第一个元素</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/2569.png" alt="结束操作"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lambda;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.omg.Messaging.SYNC_WITH_TRANSPORT;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAggregate</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Hero&gt; heros = <span class="keyword">new</span> ArrayList&lt;Hero&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            heros.add(<span class="keyword">new</span> Hero(<span class="string">&quot;hero &quot;</span> + i, r.nextInt(<span class="number">1000</span>), r.nextInt(<span class="number">100</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;遍历集合中的每个数据&quot;</span>);</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .forEach(h-&gt;System.out.print(h));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回一个数组&quot;</span>);</span><br><span class="line">        Object[] hs= heros</span><br><span class="line">            .stream()</span><br><span class="line">            .toArray();</span><br><span class="line">        System.out.println(Arrays.toString(hs));</span><br><span class="line">        System.out.println(<span class="string">&quot;返回伤害最低的那个英雄&quot;</span>);</span><br><span class="line">        Hero minDamageHero =</span><br><span class="line">        heros</span><br><span class="line">            .stream()</span><br><span class="line">            .min((h1,h2)-&gt;h1.damage-h2.damage)</span><br><span class="line">            .get();</span><br><span class="line">        System.out.print(minDamageHero);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回伤害最高的那个英雄&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        Hero mxnDamageHero =</span><br><span class="line">                heros</span><br><span class="line">                .stream()</span><br><span class="line">                .max((h1,h2)-&gt;h1.damage-h2.damage)</span><br><span class="line">                .get();</span><br><span class="line">        System.out.print(mxnDamageHero);     </span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">&quot;流中数据的总数&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> count = heros</span><br><span class="line">                .stream()</span><br><span class="line">                .count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;第一个英雄&quot;</span>);</span><br><span class="line">        Hero firstHero =</span><br><span class="line">                heros</span><br><span class="line">                .stream()</span><br><span class="line">                .findFirst()</span><br><span class="line">                .get();</span><br><span class="line">         </span><br><span class="line">        System.out.println(firstHero);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多线程即在同一时间，可以做多件事情。</p>
<p>创建多线程有3种方式，分别是<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-start/353.html#step778">继承线程类</a>,<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-start/353.html#step779">实现Runnable接口</a>,<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-start/353.html#step780">匿名类</a></p>
<p>首先要理解进程(Processor)和线程(Thread)的区别<br><strong>进程：</strong>启动一个LOL.exe就叫一个进程。 接着又启动一个DOTA.exe，这叫两个进程。<br><strong>线程：</strong>线程是在进程内部同时做的事情，比如在LOL里，有很多事情要同时做，比如”盖伦” 击杀“提莫”，<strong>同时</strong>“赏金猎人”又在击杀“盲僧”，这就是由多线程来实现的。</p>
<h2 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h2><ol>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>匿名类的方式</li>
</ol>
<p>启动线程是start()方法，run()并不能启动一个新的线程</p>
<h3 id="继承线程类"><a href="#继承线程类" class="headerlink" title="继承线程类"></a>继承线程类</h3><p>设计一个类KillThread <strong>继承Thread</strong>，<strong>并且重写run方法</strong><br>启动线程办法： 实例化一个KillThread对象，并且调用其<strong>start</strong>方法</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/778.png" alt="创建多线程-继承线程类"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KillThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Hero h1;</span><br><span class="line">    <span class="keyword">private</span> Hero h2;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KillThread</span><span class="params">(Hero h1, Hero h2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h1 = h1;</span><br><span class="line">        <span class="keyword">this</span>.h2 = h2;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!h2.isDead())&#123;</span><br><span class="line">            h1.attackHero(h2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Hero gareen = <span class="keyword">new</span> Hero();</span><br><span class="line">        gareen.name = <span class="string">&quot;盖伦&quot;</span>;</span><br><span class="line">        gareen.hp = <span class="number">616</span>;</span><br><span class="line">        gareen.damage = <span class="number">50</span>;</span><br><span class="line"> </span><br><span class="line">        Hero teemo = <span class="keyword">new</span> Hero();</span><br><span class="line">        teemo.name = <span class="string">&quot;提莫&quot;</span>;</span><br><span class="line">        teemo.hp = <span class="number">300</span>;</span><br><span class="line">        teemo.damage = <span class="number">30</span>;</span><br><span class="line">         </span><br><span class="line">        Hero bh = <span class="keyword">new</span> Hero();</span><br><span class="line">        bh.name = <span class="string">&quot;赏金猎人&quot;</span>;</span><br><span class="line">        bh.hp = <span class="number">500</span>;</span><br><span class="line">        bh.damage = <span class="number">65</span>;</span><br><span class="line">         </span><br><span class="line">        Hero leesin = <span class="keyword">new</span> Hero();</span><br><span class="line">        leesin.name = <span class="string">&quot;盲僧&quot;</span>;</span><br><span class="line">        leesin.hp = <span class="number">455</span>;</span><br><span class="line">        leesin.damage = <span class="number">80</span>;</span><br><span class="line">        <span class="comment">//实例化KillThread，并调用start()</span></span><br><span class="line">        KillThread killThread1 = <span class="keyword">new</span> KillThread(gareen,teemo);</span><br><span class="line">        killThread1.start();</span><br><span class="line">        KillThread killThread2 = <span class="keyword">new</span> KillThread(bh,leesin);</span><br><span class="line">        killThread2.start();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>创建类Battle，实现Runnable接口<br>启动的时候，首先创建一个Battle对象，然后再根据该battle对象创建一个线程对象，并启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化battle类，并创建线程对象，同时start()</span></span><br><span class="line">Battle battle1 = <span class="keyword">new</span> Battle(gareen,teemo);</span><br><span class="line"><span class="keyword">new</span> Thread(battle1).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Battle实现了Runnable接口，类里必须实现run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Battle</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!h2.isDead())&#123;</span><br><span class="line">            h1.attackHero(h2);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>battle1 对象实现了Runnable接口，所以有run方法，但是直接调用run方法，并不会启动一个新的线程。<br>必须，借助一个线程对象的start()方法，才会启动一个新的线程。<br>所以，在创建Thread对象的时候，把battle1作为构造方法的参数传递进去，这个线程启动的时候，就会去执行battle1.run()方法了。</p>
<h3 id="匿名类-1"><a href="#匿名类-1" class="headerlink" title="匿名类"></a>匿名类</h3><p>使用<a target="_blank" rel="noopener" href="https://how2j.cn/k/interface-inheritance/interface-inheritance-inner-class/322.html#step687">匿名类</a>，继承Thread,重写run方法，直接在run方法中写业务代码<br>匿名类的一个好处是可以很方便的访问外部的局部变量。<br>前提是外部的局部变量需要被声明为final。(JDK7以后就不需要了)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//匿名类</span></span><br><span class="line">        Thread t1= <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//匿名类中用到外部的局部变量teemo，必须把teemo声明为final</span></span><br><span class="line">                <span class="comment">//但是在JDK7以后，就不是必须加final的了</span></span><br><span class="line">                <span class="keyword">while</span>(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;; <span class="comment">//注意有分号</span></span><br><span class="line">        t1.start();</span><br><span class="line">          </span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!leesin.isDead())&#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见线程方法"><a href="#常见线程方法" class="headerlink" title="常见线程方法"></a>常见线程方法</h2><p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200816112552711.png" alt="image-20200816112552711"></p>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><p>Thread.sleep(1000); 表示当前线程暂停1000毫秒 ，其他线程不受影响</p>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>Thread.join()</p>
<p>首先解释一下<strong>主线程</strong>的概念<br>所有进程，至少会有一个线程即主线程，即main方法开始执行，就会有一个<strong>看不见</strong>的主线程存在。<br>在42行执行t.join，即表明<strong>在主线程中加入该线程</strong>。<br>主线程会等待该线程结束完毕， 才会往下运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        Thread t1= <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!teemo.isDead())&#123;</span><br><span class="line">                    gareen.attackHero(teemo);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">          </span><br><span class="line">        t1.start();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//代码执行到这里，一直是main线程在运行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//t1线程加入到main线程中来，只有t1线程运行结束，才会继续往下走</span></span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Thread t2= <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!leesin.isDead())&#123;</span><br><span class="line">                    bh.attackHero(leesin);</span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//会观察到盖伦把提莫杀掉后，才运行t2线程</span></span><br><span class="line">        t2.start();       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority()"></a>setPriority()</h3><p>Thread.setPrioritY()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">t2.setPriority(Thread.MIN_PRIORITY);</span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><p>Thread.yield();<br>当前线程，临时暂停，使得其他线程可以有更多的机会占用CPU资源</p>
<h3 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon()"></a>setDaemon()</h3><p>守护线程的概念是： 当一个进程里，所有的线程都是守护线程的时候，结束当前进程。</p>
<p>就好像一个公司有销售部，生产部这些和业务挂钩的部门。<br>除此之外，还有后勤，行政等这些支持部门。</p>
<p>如果一家公司销售部，生产部都解散了，那么只剩下后勤和行政，那么这家公司也可以解散了。</p>
<p>守护线程就相当于那些支持部门，如果一个进程只剩下守护线程，那么进程就会自动结束。</p>
<p>守护线程通常会被用来做日志，性能统计等工作。</p>
<p>比如下面这个程序，setDaemon(true)后，t1.start()程序也不会执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">        Thread t1= <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> seconds =<span class="number">0</span>;</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.printf(<span class="string">&quot;已经玩了LOL %d 秒%n&quot;</span>, seconds++);</span><br><span class="line">                     </span><br><span class="line">                &#125;              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题</p>
<p>多线程的问题，又叫<strong>Concurrency</strong> 问题</p>
<p><strong>synchronized 同步对象概念</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object someObject =<span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span> (someObject)&#123;</span><br><span class="line">  <span class="comment">//此处的代码只有占有了someObject后才可以执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized表示当前线程，独占 对象 someObject</strong><br>当前线程<strong>独占</strong> 了对象someObject，如果有<strong>其他线程试图占有对象</strong>someObject，<strong>就会等待</strong>，直到当前线程释放对someObject的占用。<br>someObject 又叫同步对象，所有的对象，都可以作为同步对象<br>为了达到同步的效果，必须使用同一个同步对象</p>
<p><strong>释放同步对象</strong>的方式： synchronized 块自然结束，或者有异常抛出</p>
<p><strong>使用hero对象作为同步对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hurt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用this作为同步对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            hp=hp-<span class="number">1</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在方法前，加上修饰符synchronized</strong></p>
<p>在recover前，直接加上synchronized ，其所对应的同步对象，就是this<br>和hurt方法达到的效果是一样<br>外部线程访问gareen的方法，就不需要额外使用synchronized 了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hp=hp+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程安全的类"><a href="#线程安全的类" class="headerlink" title="线程安全的类"></a>线程安全的类</h2><p>如果一个类，其<strong>方法都是有synchronized修饰的</strong>，那么该类就叫做<strong>线程安全的类</strong></p>
<p>同一时间，只有一个线程能够进入 <strong>这种类的一个实例</strong> 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)</p>
<p>比如StringBuffer和StringBuilder的区别<br>StringBuffer的方法都是有synchronized修饰的，StringBuffer就叫做线程安全的类<br>而StringBuilder就不是线程安全的类</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/793.png" alt="线程安全的类"></p>
<h3 id="HashMap-vs-HashTable-1"><a href="#HashMap-vs-HashTable-1" class="headerlink" title="HashMap vs HashTable"></a>HashMap vs HashTable</h3><p>HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式<br>区别1：<br>HashMap可以存放 null<br>Hashtable不能存放null<br>区别2：<br>HashMap不是<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-synchronized/355.html#step793">线程安全的类</a><br>Hashtable是线程安全的类</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/2595.png" alt="HashMap和Hashtable的区别"></p>
<h3 id="StringBuffer-vs-StringBuilder"><a href="#StringBuffer-vs-StringBuilder" class="headerlink" title="StringBuffer vs StringBuilder"></a>StringBuffer vs StringBuilder</h3><p>StringBuffer 是线程安全的<br>StringBuilder 是非线程安全的</p>
<p>所以当进行大量字符串拼接操作的时候，如果是单线程就用StringBuilder会更快些，如果是多线程，就需要用StringBuffer 保证数据的安全性</p>
<p><strong>非线程安全的</strong>为什么会比<strong>线程安全的</strong> 快？ 因为不需要同步嘛，省略了些时间</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/2596.png" alt="StringBuffer和StringBuilder的区别"></p>
<h3 id="ArrayList-vs-Vector"><a href="#ArrayList-vs-Vector" class="headerlink" title="ArrayList vs Vector"></a>ArrayList vs Vector</h3><p>ArrayList类的声明：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>Vector类的声明：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>

<p>一模一样的~<br>他们的区别也在于，Vector是线程安全的类，而ArrayList是非线程安全的。</p>
<h3 id="把非线程安全的集合转换为线程安全"><a href="#把非线程安全的集合转换为线程安全" class="headerlink" title="把非线程安全的集合转换为线程安全"></a>把非线程安全的集合转换为线程安全</h3><p>ArrayList是非线程安全的，换句话说，多个线程可以同时进入<strong>一个ArrayList对象</strong>的add方法</p>
<p>借助Collections.synchronizedList，可以把ArrayList转换为线程安全的List。</p>
<p>与此类似的，还有HashSet,LinkedList,HashMap等等非线程安全的类，都通过<a target="_blank" rel="noopener" href="https://how2j.cn/k/collection/collection-collections/369.html">工具类Collections</a>转换为线程安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list2 = Collections.synchronizedList(list1);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>很有意思的一个例子</p>
<p>一直等待程序也不结束。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200816143321706.png" alt="image-20200816143321706"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> charactor.Hero;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Hero ahri = <span class="keyword">new</span> Hero();</span><br><span class="line">        ahri.name = <span class="string">&quot;九尾妖狐&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> Hero annie = <span class="keyword">new</span> Hero();</span><br><span class="line">        annie.name = <span class="string">&quot;安妮&quot;</span>;</span><br><span class="line">         </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//占有九尾妖狐</span></span><br><span class="line">                <span class="keyword">synchronized</span> (ahri) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 已占有九尾妖狐&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//停顿1000毫秒，另一个线程有足够的时间占有安妮</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                     </span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 试图占有安妮&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;t1 等待中 。。。。&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (annie) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//占有安妮</span></span><br><span class="line">                <span class="keyword">synchronized</span> (annie) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 已占有安妮&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                         </span><br><span class="line">                        <span class="comment">//停顿1000毫秒，另一个线程有足够的时间占有暂用九尾妖狐</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 试图占有九尾妖狐&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;t2 等待中 。。。。&quot;</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (ahri) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><p>在Hero类中：hurt()减血方法：当hp=1的时候，执行this.wait().<br>this.wait()<strong>表示 让占有this的线程等待，并临时释放占有</strong><br>进入hurt方法的线程必然是减血线程，this.wait()会让减血线程临时释放对this的占有。 <strong>这样加血线程，就有机会进入recover()加血方法了</strong>。</p>
<p>recover() 加血方法：增加了血量，执行this.notify();<br>this.notify() 表示通知那些<strong>等待在this的线程</strong>，可以苏醒过来了。 等待在this的线程，恰恰就是减血线程。 一旦recover()结束， 加血线程释放了this，减血线程，就可以重新占有this，并执行后面的减血工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hp = hp + <span class="number">1</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s 回血1点,增加血后，%s的血量是%.0f%n&quot;</span>, name, name, hp);</span><br><span class="line">        <span class="comment">// 通知那些等待在this对象上的线程，可以醒过来了，如第20行，等待着的减血线程，苏醒过来</span></span><br><span class="line">        <span class="keyword">this</span>.notify();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">hurt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hp == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 让占有this的减血线程，暂时释放对this的占有，并等待</span></span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        hp = hp - <span class="number">1</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s 减血1点,减少血后，%s的血量是%.0f%n&quot;</span>, name, name, hp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于wait、notify和notifyAll</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200816145619013.png" alt="image-20200816145619013"></p>
<p>这里需要强调的是，wait方法和notify方法，并<strong>不是Thread线程上的方法</strong>，它们是Object上的方法。</p>
<p>因为所有的Object都可以被用来作为同步对象，所以准确的讲，wait和notify是同步对象上的方法。</p>
<p>wait()的意思是： 让占用了这个同步对象的<strong>线程</strong>，临时释放当前的占用，并且等待。 所以调用wait是有前提条件的，一定是在synchronized块里，否则就会出错。</p>
<p>notify() 的意思是，通知<strong>一个</strong>等待在这个同步对象上的线程，<strong>你</strong>可以苏醒过来了，有机会重新占用当前对象了。</p>
<p>notifyAll() 的意思是，通知<strong>所有的</strong>等待在这个同步对象上的线程，<strong>你们</strong>可以苏醒过来了，有机会重新占用当前对象了。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>Java自带的线程池</strong></p>
<p><code>ThreadPoolExecutor threadPool= new ThreadPoolExecutor(10, 15, 60, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());</code></p>
<p><strong>第一个</strong>参数10 表示这个线程池<strong>初始化了10个</strong>线程在里面工作<br><strong>第二个</strong>参数15 表示如果10个线程不够用了，就会自动增加到<strong>最多15个线程</strong><br><strong>第三个</strong>参数60 结合第四个参数TimeUnit.SECONDS，表示经过<strong>60秒</strong>，多出来的线程还没有接到活儿，就会回收，最后保持池子里就10个<br><strong>第四个</strong>参数TimeUnit.SECONDS 如上<br><strong>第五个</strong>参数 new LinkedBlockingQueue() 用来放任务的集合</p>
<p><strong>execute</strong>方法用于添加新的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">           </span><br><span class="line">        ThreadPoolExecutor threadPool= <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">15</span>, <span class="number">60</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">           </span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">   </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                System.out.println(<span class="string">&quot;任务1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">               </span><br><span class="line">        &#125;);</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lock对象"><a href="#Lock对象" class="headerlink" title="Lock对象"></a>Lock对象</h2><p>与synchronized类似的，lock也能够达到同步的效果，但是需要unlock释放</p>
<p>Lock是一个接口，为了使用一个Lock对象，需要用到</p>
<p><code>Lock lock = new ReentrantLock();</code></p>
<p>与 <strong>synchronized (someObject)</strong> 类似的，<strong>lock()**方法，表示当前线程占用lock对象，一旦占用，其他线程就不能占用了。<br>与 **synchronized</strong> 不同的是，一旦synchronized 块结束，就会自动释放对<strong>someObject</strong>的占用。 lock却必须调用<strong>unlock</strong>方法进行手动释放，为了保证释放的执行，往往会把unlock() 放在finally中进行。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/2611.png" alt="使用Lock对象实现同步效果"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s %s %s %n&quot;</span>, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                    lock.lock();</span><br><span class="line"> </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先让t1飞2秒</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                    lock.lock();</span><br><span class="line"> </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>trylock方法</strong></p>
<p>ynchronized 是<strong>不占用到手不罢休</strong>的，会一直试图占用下去。<br>与 synchronized 的<strong>钻牛角尖</strong>不一样，Lock接口还提供了一个trylock方法。<br>trylock会在指定时间范围内<strong>试图占用</strong>，占成功了，就开始。 如果时间到了，还占用不成功，扭头就走~</p>
<p>注意： 因为使用trylock有可能成功，有可能失败，所以后面unlock释放锁的时候，需要判断是否占用成功了，如果没占用成功也unlock,就会抛出异常</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/2612.png" alt="trylock方法"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s %s %s %n&quot;</span>, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"> </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                    locked = lock.tryLock(<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                        log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        log(<span class="string">&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先让t1飞2秒</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                    locked = lock.tryLock(<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                        log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        log(<span class="string">&quot;经过1秒钟的努力，还没有占有对象，放弃占有&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                     </span><br><span class="line">                    <span class="keyword">if</span>(locked)&#123;</span><br><span class="line">                        log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程交互</strong></p>
<p>使用synchronized方式进行线程交互，用到的是同步对象的wait,notify和notifyAll方法</p>
<p>Lock也提供了类似的解决办法，首先通过lock对象得到一个Condition对象，然后分别调用这个Condition对象的：<strong>await</strong>, <strong>signal</strong>,<strong>signalAll</strong> 方法</p>
<p><strong>注意</strong>： 不是Condition对象的wait,nofity,notifyAll方法,是await,signal,signalAll</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/2617.png" alt="线程交互"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s %s %s %n&quot;</span>, now() , Thread.currentThread().getName() , msg);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line">         </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line">  </span><br><span class="line">                    lock.lock();</span><br><span class="line">  </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    log(<span class="string">&quot;临时释放对象 lock， 并等待&quot;</span>);</span><br><span class="line">                    condition.await();</span><br><span class="line">                    log(<span class="string">&quot;重新占有对象 lock，并进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先让t1飞2秒</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;线程启动&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;试图占有对象：lock&quot;</span>);</span><br><span class="line">  </span><br><span class="line">                    lock.lock();</span><br><span class="line">  </span><br><span class="line">                    log(<span class="string">&quot;占有对象：lock&quot;</span>);</span><br><span class="line">                    log(<span class="string">&quot;进行5秒的业务操作&quot;</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    log(<span class="string">&quot;唤醒等待中的线程&quot;</span>);</span><br><span class="line">                    condition.signal();</span><br><span class="line">  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    log(<span class="string">&quot;释放对象：lock&quot;</span>);</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                log(<span class="string">&quot;线程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>总结Lock和synchronized的区别</strong></p>
<ol>
<li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。</li>
<li>Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。</li>
<li>synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。</li>
</ol>
<h2 id="原子访问"><a href="#原子访问" class="headerlink" title="原子访问"></a>原子访问</h2><p>所谓的<strong>原子性操作</strong>即不可中断的操作，比如赋值操作<code>int i = 5;</code></p>
<p><strong>原子性操作本身是线程安全的</strong><br>但是 i++ 这个行为，事实上是有3个原子性操作组成的。<br>步骤 1. 取 i 的值<br>步骤 2. i + 1<br>步骤 3. 把新的值赋予i<br>这三个步骤，每一步都是一个原子操作，但是合在一起，就不是原子操作。就<strong>不是线程安全</strong>的。<br>换句话说，一个线程在步骤1 取i 的值结束后，还没有来得及进行步骤2，另一个线程也可以取 i的值了。<br>这也是<a target="_blank" rel="noopener" href="https://how2j.cn/k/thread/thread-synchronized/355.html#step787">分析同步问题产生的原因</a> 中的原理。<br>i++ ，i–， i = i+1 这些都是非原子性操作。<br>只有int i = 1,这个赋值操作是原子性的。</p>
<p><strong>AtomicInteger</strong></p>
<p>JDK6 以后，新增加了一个包<strong>java.util.concurrent.atomic</strong>，里面有各种原子类，比如<strong>AtomicInteger</strong>。<br>而AtomicInteger提供了各种自增，自减等方法，这些方法都是原子性的。 换句话说，自增方法 <strong>incrementAndGet</strong> 是线程安全的，同一个时间，只有一个线程可以调用这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multiplethread;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        AtomicInteger atomicI =<span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">int</span> i = atomicI.decrementAndGet();</span><br><span class="line">        <span class="keyword">int</span> j = atomicI.incrementAndGet();</span><br><span class="line">        <span class="keyword">int</span> k = atomicI.addAndGet(<span class="number">3</span>);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="工具和中间件"><a href="#工具和中间件" class="headerlink" title="工具和中间件"></a>工具和中间件</h1><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="Java应用Debug"><a href="#Java应用Debug" class="headerlink" title="Java应用Debug"></a>Java应用Debug</h3><ol>
<li><p>代码</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808111239280.png" alt="image-20200808111239280"></p>
</li>
<li><p>设置断点</p>
<p>行号后单击鼠标左键（Intellij）</p>
<p>eclipse是双击</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808111431365.png" alt="image-20200808111431365"></p>
</li>
<li><p>点击调试按钮</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808111631396.png" alt="image-20200808111631396"></p>
<p><strong>注：</strong> 需要注意的是，当前类，一定要有主方法，否则就会调试到 <strong>上一次成功运行的程序</strong></p>
</li>
<li><p>调试视觉</p>
<ul>
<li><p>当前是哪个线程，因为是非多线程程序，所以就是主线程</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808112056486.png" alt="image-20200808112056486"></p>
</li>
<li><p>变量的值，这个就是调试的主要作用，观察这些值的多少，进行分析问题所在或者理解代码逻辑</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808112132007.png" alt="image-20200808112132007"></p>
</li>
<li><p>当前代码，表示<strong>马上就要运行蓝色的那一行</strong>，但是还没有来得及运行第八行</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808112204867.png" alt="image-20200808112204867"></p>
</li>
<li><p>控制台输出</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808112235141.png" alt="image-20200808112235141"></p>
</li>
</ul>
</li>
<li><p>单步运行</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808130402732.png" alt="image-20200808130402732"></p>
<blockquote>
<p>step into 上面第二个按钮是什么意思？</p>
</blockquote>
</li>
<li><p>退出</p>
<p><img src= "/img/loading.gif" data-lazy-src="/2020/08/19/Java%E5%9F%BA%E7%A1%80/image-20200808130547648.png" alt="image-20200808130547648"></p>
</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Chen Jiahui</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/08/19/Java%E5%9F%BA%E7%A1%80/">http://yoursite.com/2020/08/19/Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">ChenChenChen's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/25/MAVEN%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AETomcat%E6%8F%90%E7%A4%BAjavax-servlet-http%E4%B8%8D%E5%AD%98%E5%9C%A8/"><img class="prev-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MAVEN项目配置Tomcat提示javax.servlet.http不存在</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/19/PINNs/"><img class="next-cover" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">PINNs</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Chen Jiahui</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>